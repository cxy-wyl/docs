<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概述 | Jami's blog</title>
    <meta name="description" content="自我介绍">
    <meta name="generator" content="VitePress v1.2.2">
    <link rel="preload stylesheet" href="/assets/style.DMALNguD.css" as="style">
    
    <script type="module" src="/assets/app.caW0TtKn.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.DnJ-_PtE.js">
    <link rel="modulepreload" href="/assets/chunks/theme.ZJfuJUq1.js">
    <link rel="modulepreload" href="/assets/computed_network.md.gSfoJl5P.lean.js">
    <link rel="icon" href="/logo.svg">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
    <script>import("/pagefind/pagefind.js").then(i=>{window.__pagefind__=i,i.init()}).catch(()=>{});</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1125a642><!--[--><!--]--><!--[--><span tabindex="-1" data-v-d8299c56></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-d8299c56> Skip to content </a><!--]--><!----><header class="VPNav" data-v-1125a642 data-v-b0f86e71><div class="VPNavBar top" data-v-b0f86e71 data-v-029182b1><div class="wrapper" data-v-029182b1><div class="container" data-v-029182b1><div class="title" data-v-029182b1><div class="VPNavBarTitle" data-v-029182b1 data-v-99675619><a class="title" href="/" data-v-99675619><!--[--><!--]--><!--[--><img class="VPImage logo" src="logo.svg" alt data-v-bb29ad85><!--]--><span data-v-99675619>Jami&#39;s blog</span><!--[--><!--]--></a></div></div><div class="content" data-v-029182b1><div class="content-body" data-v-029182b1><!--[--><!--]--><div class="blog-search search" data-pagefind-ignore="all" data-v-029182b1 data-v-df5b5348><div class="nav-search-btn-wait" data-v-df5b5348><span data-v-df5b5348><svg width="14" height="14" viewBox="0 0 20 20" data-v-df5b5348><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" data-v-df5b5348></path></svg></span><span class="search-tip" data-v-df5b5348>Search</span><span class="metaKey" data-v-df5b5348> K </span></div><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-029182b1 data-v-11ce55f4><span id="main-nav-aria-label" class="visually-hidden" data-v-11ce55f4>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/tool/index" tabindex="0" data-v-11ce55f4 data-v-3ff40e85><!--[--><span data-v-3ff40e85>官网合集</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-11ce55f4 data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-fdead9c6><span class="text" data-v-fdead9c6><!----><span data-v-fdead9c6>计算机基础</span><span class="vpi-chevron-down text-icon" data-v-fdead9c6></span></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><div class="items" data-v-0b80e106><!--[--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/computed/dataStructure" data-v-7345a99e><!--[-->数据结构<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link active" href="/computed/network" data-v-7345a99e><!--[-->计算机网络<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/computed/organization" data-v-7345a99e><!--[-->计算机组成原理<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/computed/os" data-v-7345a99e><!--[-->操作系统<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/computed/compiler" data-v-7345a99e><!--[-->编译原理<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/computed/designPattern" data-v-7345a99e><!--[-->设计模式<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-11ce55f4 data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-fdead9c6><span class="text" data-v-fdead9c6><!----><span data-v-fdead9c6>语言</span><span class="vpi-chevron-down text-icon" data-v-fdead9c6></span></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><div class="items" data-v-0b80e106><!--[--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/language/index" data-v-7345a99e><!--[-->概述<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/language/html" data-v-7345a99e><!--[-->HTML<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/language/css" data-v-7345a99e><!--[-->CSS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/language/js/index" data-v-7345a99e><!--[-->JS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/language/ts" data-v-7345a99e><!--[-->TS<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-11ce55f4 data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-fdead9c6><span class="text" data-v-fdead9c6><!----><span data-v-fdead9c6>客户端</span><span class="vpi-chevron-down text-icon" data-v-fdead9c6></span></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><div class="items" data-v-0b80e106><!--[--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/pc/index" data-v-7345a99e><!--[-->PC<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/mobile/index" data-v-7345a99e><!--[-->移动端<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/dataVisual/index" data-v-7345a99e><!--[-->数据可视化<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/webgis/index" data-v-7345a99e><!--[-->WEBGIS<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-11ce55f4 data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-fdead9c6><span class="text" data-v-fdead9c6><!----><span data-v-fdead9c6>工程化</span><span class="vpi-chevron-down text-icon" data-v-fdead9c6></span></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><div class="items" data-v-0b80e106><!--[--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/cli" data-v-7345a99e><!--[-->脚手架(cli)<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/node/index" data-v-7345a99e><!--[-->Git<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/engineering/buildTool" data-v-7345a99e><!--[-->打包工具<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/engineering/pkgTool" data-v-7345a99e><!--[-->包管理工具<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/engineering/performance" data-v-7345a99e><!--[-->性能 监控 埋点<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/nvm" data-v-7345a99e><!--[-->node nvm npm安装<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/nvm" data-v-7345a99e><!--[-->CSS工程化<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/nvm" data-v-7345a99e><!--[-->axios fetch mock<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-11ce55f4 data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-fdead9c6><span class="text" data-v-fdead9c6><!----><span data-v-fdead9c6>日常记录</span><span class="vpi-chevron-down text-icon" data-v-fdead9c6></span></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><div class="items" data-v-0b80e106><!--[--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/records/index" data-v-7345a99e><!--[-->功能问题合集<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/nvm" data-v-7345a99e><!--[-->组件库<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-0b80e106 data-v-7345a99e><a class="VPLink link" href="/common/nvm" data-v-7345a99e><!--[-->低代码<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/resume/index" tabindex="0" data-v-11ce55f4 data-v-3ff40e85><!--[--><span data-v-3ff40e85>我的简历</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-029182b1 data-v-27c16a5b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-27c16a5b data-v-ea4f3921 data-v-3b61c412><span class="check" data-v-3b61c412><span class="icon" data-v-3b61c412><!--[--><span class="vpi-sun sun" data-v-ea4f3921></span><span class="vpi-moon moon" data-v-ea4f3921></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-029182b1 data-v-1931269c data-v-fdead9c6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-fdead9c6><span class="vpi-more-horizontal icon" data-v-fdead9c6></span></button><div class="menu" data-v-fdead9c6><div class="VPMenu" data-v-fdead9c6 data-v-0b80e106><!----><!--[--><!--[--><!----><div class="group" data-v-1931269c><div class="item appearance" data-v-1931269c><p class="label" data-v-1931269c>Appearance</p><div class="appearance-action" data-v-1931269c><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-1931269c data-v-ea4f3921 data-v-3b61c412><span class="check" data-v-3b61c412><span class="icon" data-v-3b61c412><!--[--><span class="vpi-sun sun" data-v-ea4f3921></span><span class="vpi-moon moon" data-v-ea4f3921></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-029182b1 data-v-878d21a3><span class="container" data-v-878d21a3><span class="top" data-v-878d21a3></span><span class="middle" data-v-878d21a3></span><span class="bottom" data-v-878d21a3></span></span></button></div></div></div></div><div class="divider" data-v-029182b1><div class="divider-line" data-v-029182b1></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-1125a642 data-v-cd042422><div class="container" data-v-cd042422><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-cd042422 data-v-4203718d><button data-v-4203718d>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-pagefind-body data-v-1125a642 data-v-83ad444f><div class="VPDoc has-aside" data-v-83ad444f data-v-01c1258a><!--[--><!--]--><div class="container" data-v-01c1258a><div class="aside" data-v-01c1258a><div class="aside-curtain" data-v-01c1258a></div><div class="aside-container" data-v-01c1258a><div class="aside-content" data-v-01c1258a><div class="VPDocAside" data-v-01c1258a data-v-b99ce71c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-b99ce71c data-v-19c25cdd><div class="content" data-v-19c25cdd><div class="outline-marker" data-v-19c25cdd></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-19c25cdd>页面导航</div><ul class="VPDocOutlineItem root" data-v-19c25cdd data-v-e57bdbaf><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-b99ce71c></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-01c1258a><div class="content-container" data-v-01c1258a><!--[--><!--]--><main class="main" data-v-01c1258a><div style="position:relative;" class="vp-doc _computed_network" data-v-01c1258a><div><h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><p>从下往上学习 硬件设备网卡将数字信号转为电信号发出去 网卡是硬件的一部分，主要用于数据的收发和管理，而网关是网络间的桥梁，负责数据包的转发和路由。 网卡路由器：同一网段 数据转发 IP映射表 网关：确保不同网段的主机可以通过网关进行通信 IP端对端，找主机 TCP找端口，点对点，找主机中的进程 HTTP：应用中客户端和服务端收发数据</p><h2 id="网络简史" tabindex="-1">网络简史 <a class="header-anchor" href="#网络简史" aria-label="Permalink to &quot;网络简史&quot;">​</a></h2><p>网络分类 作用范围</p><p>使用者：公网、专用网 互联网历史</p><ol><li><p>1969美国国防部创建单个网络ARPANET，通过交换机连接就近的计算机</p></li><li><p>三级结构互联网，将美国所有大学，研究所网络连接起来</p></li><li><p>多层次ISP互联网，网络服务提供商，如：电信、联通、移动。不同国家通过主干ISP连接，海底电缆传输数据。</p></li></ol><p>中国互联网历史 1980年开始实验，1989年建立公共网络，1994年接入国际互联网 五大公共网络：电信、移动、联调、教育与科研、科学技术网</p><h2 id="网络层次结构" tabindex="-1">网络层次结构 <a class="header-anchor" href="#网络层次结构" aria-label="Permalink to &quot;网络层次结构&quot;">​</a></h2><p>为什么需要层次结构设计？ 因为网络要保证数据通畅、能识别目的计算机、查询目的计算机的状态、数据错误的判断，所以采用分层设计各自实现不同的功能 设计原则</p><ol><li>各层之间相互独立、完全解耦</li><li>每层有足够灵活性 OSI七层模型</li></ol><p>应用层(报文，浏览器拿到ip) 定义应用进程间的交互规则，通过应用程序间的交互来完成特定的网络应用，通过不同协议为不同网络应用提供服务。DNS，HTTP，SMTP 表示层 使应用程序能解释交换数据的含义，向上为应用层提供服务，向下接收会话层服务数据压缩，加密及描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异 会话层 建立、管理和终止表示层实体间的通信会话提供数据交换的定界和同步功能，建立检查点和恢复方案的方法 传输层 (数据包，指定两端port，tcp，udp)两台主机进程间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题传输层向高屏蔽了下层数据通信的细节。是关键的一层主要是 TCP 和 UDP 网络层 (IP数据报)指定两端ip计算机间传数据时通信链路不止一条，传输的信息可能经过很多通信子网选择合适的网间路由和交换节点，确保数据按时成功传送发数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传到数据链路层网络层使用的协议是无连接的网际协议（Internet Protocol）和路由协议，把该层称为 IP 层 数据链路层 (mac地址，帧) 物理层和网络层之间。两台主机间数据传输，总是在一段一段的链路上传送，要用专门的链路层协议相邻节点间传数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧每一帧的数据可以分成：报头 head 和数据 data 两部分:head 标明数据发送者、接受者、数据类型，如 MAC 地址data 存储计算机之间交互的数据通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源 物理层 (比特流，网线，网卡)计算机节点之间比特流的透明传送,硬件有关 TCP/IP四层模型</p><ul><li>应用层报文被传送到运输层</li><li>简单情况下，运输层收到报文并附上附加信息，该首部被接收端的运输层使用</li><li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li><li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li><li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li><li>物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li><li>对端一步步解开封装，获取到传送的数据 AB通过路由器连接，A通过网络接口层和路由器通信，路由器只到了网络层，然后路由器将数据进行转发到B的网络接口层</li></ul><p>协议</p><p>网络拓扑结构</p><ol><li>边缘部分 家、公司、商场的一些终端通过无线wife连接到路由器，路由器与当地的网关连接，一个网关可以连多个路由器，网关通过线路连接当地的ISP网络运营商，电信/移动</li></ol><p>企业内部：工位电脑通过网线、笔记本通过wifi连接到网关、内部可以有多个网关互相关联，最终有统一网关连接地区ISP</p><ol start="2"><li><p>核心部分 上文的地区ISP连接主干ISP，国内主干ISP相互连接并通过国际路由器与其他国家的主干ISP连接，传输过程主要有海底电缆，跨地区电缆，通信设备主要由移动运营商铺设</p></li><li><p>综合</p></li></ol><p>主干ISP代表不同国家，通过海底电缆连接，地区ISP代表不同省或地区，依次向下的树状结构</p><p>C/S客户服务器模式 多个设备通过互联网连接，个人计算机发起请求服务，请求服务通过路由传到服务器，服务器收到请求并响应</p><p>P2P对等连接模式 多个终端通过网络边缘部分连接到网络核心部分，只要终端运行P2P程序，就能对等连接，比如迅雷，提高下载速度</p><p>网络性能指标 速率：bps=bit/s</p><p>时延：发送时延+传播时延+排队时延+处理时延 发送时延：本机进行网络发送时候在本机停留的时间，是数据长度/发送速率，发送速率由网卡决定也就是每秒中发送多少bit数据</p><p>传播时延：传播路径距离/传播速率，传播速率受限于介质，介质包括铜线 光纤</p><p>排队时延：数据包在网络设备路由器中等待被处理的时间，一个数据包发送到路由器不会立即被处理，要排队等待 处理时延：数据包到达目标主机后被处理所需要的时间，若目标服务器性能差，收到数据后不会立即处理</p><p>往返时间RTT Route Trip Time：数据报文在端到端通信中来回一次所需要的时间，比如：本机对远端服务器请求，请求报文去到服务器并返回的过程所需要的时间。(毫秒)，和IP实际距离有关 实践 一般通过ping查看网络质量 按下回车 页面卸载(如果有旧页面) DNS 解析 域名转为IP TCP 连接 三次握手，应⽤层下发数据给传输层，TCP 协议指明两端端⼝号，然后下发给⽹络层。⽹络层中 IP 协议确定 IP 地址，并指示数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层⾯的传输了， TCP 握⼿结束后会进⾏ TLS 握⼿，然后就开始正式的传输数据 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 进⼊服务端之前，可能先经过负责负载均衡的服务器，它的作⽤就是将请求合 理的分发到多台服务器上，这时假设服务端会响应⼀个 HTML ⽂件 浏览器解析加载页面 从服务端拿到html文件/二进制/字符串。⾸先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进⾏重定向，这⾥会有个重定向计数器，避免过多次的重定向，超过次数也会报错。 浏览器开始解析⽂件，如果是 gzip 格式的话会先解压⼀下，然后通过⽂件的编码格式知 道该如何去解码⽂件 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容 浏览器渲染页面 ⽂件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer，前者会并⾏进⾏下载并执⾏ JS，后者会先下载⽂件，然后等待 HTML 解析完成后顺序执⾏，如果以上都没有，就会阻塞住渲染流程直到 JS 执⾏完毕。遇到⽂件下载的会去下载⽂件，这⾥如果使⽤ HTTP 2.0 协议的话会极⼤的提⾼多图的下载效率。初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件。 局、样式等等诸多⽅⾯的东⻄。 签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是CSS 或者 JS 格式的。 浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— 为何要将 CSS 放在 HTML 头部？—— 这样会让浏览器尽早拿到 CSS 尽早生成CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在HTML 底部，会出现渲染卡顿的情况，影响性能和体验。 连接结束 输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http 请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html 代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸， 之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析 DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires 使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match 的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p><p>解析url，给搜索引擎/转义，ifcatch(source/ip)，dns解析获取ip，获取target的mac地址，tcp3次握手/TLS4次握手，返回数据(html 文件)，解析html文件并渲染tcp4次挥手 （1）解析 URL：分析传输协议和请求资源路径。如果 URL 中协议或主机名不合法，会把地址栏输入的内容传给搜索引擎。如果没问题，浏览器会检查 URL 中是否出现非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 （2）缓存判断：浏览器判断请求资源是否在缓存里，如果请求资源在缓存且没失效，直接用，否则向服务器发起新的请求。 （3）DNS 解析：获取输入 URL 中的域名的 IP，先判断本地是否有该域名的 IP 地址缓存，如果有则用，没有则向本地 DNS 服务器发请求。本地 DNS 服务器会先检查是否存在缓存，没有就先向根域名服务器发请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 （4）获取 MAC 地址：浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 （5）TCP 三次握手：首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 （6）HTTPS 握手：客户向服务端发送用的协议版本号、一个随机数和可用的加密方法。服务端收到后，确认加密方法，向客户端发个随机数和自己的数字证书。客户端收到后，先检查数字证书是否有效，如果有效，再生成一个随机数，并用证书中的公钥对随机数加密，发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。握手时用ECDHE算法密钥交换，RSA签名和身份认证，握手后用AES对称算法，密钥长度256位，分组模式是GCM，摘要算法SHA384用于消息认证和产生随机数 （7）返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 （8）页面渲染：当浏览器接收到服务器响应的资源后，首先资源解析： 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源 查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式 解析HTML，构建 DOM 树，解析 CSS ，生成 CSS 规则树，合并 DOM 树和 CSS 规则，生成 render 树 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算，绘制 render 树（ paint ），绘制页面像素信息 浏览器将各层信息发给 GPU，GPU 将各层合成（ composite ），显示在屏幕上 （9）TCP 四次挥手：客户端认为数据发送完成，向服务端发连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。 eb页面请求过程</p><ol><li>生成DNS查询报文：主机生成一个DNS查询报文，将要访问的主机名放入DNS报文中。该DNS报文则放置到一个具有53号目的端口（DNS服务器）的UDP报文段中。报文段则放入以DNS服务器为目的IP地址的数据报中。主机则将包含DNS请求报文的数据报放入一个以太网帧中。该帧将被交换机发往学校网络中的网关路由器。</li><li>通过ARP查询报文获取目的IP地址的MAC地址：主机在发送DNS查询报文前先生成一个ARP查询报文，将该以太网帧（ARP查询报文所在的）通过交换机发送到所有连接的设备，包括网关路由器。路由器发现该以太网帧的目的IP地址与自己的IP地址相符则准备一个ARP回应报文，将ARP请求报文中IP地址对应的MAC地址写入ARP回应报文，通过交换机再交还给请求主机。主机从ARP回答报文中抽取网关路由器的MAC地址，至此，主机终于能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。注意：DNS查询报文中，IP数据报具有目的IP地址，报文所在的以太网帧具有网关路由器的MAC地址，该MAC地址是用来寻找下一跳路由器的物理地址。</li><li>获取IP地址：网关路由器接收到以太网帧（DNS请求报文所在的）并抽取其中包含DNS查询的IP数据报。通过转发表确定下一跳路由器。依次，最终以太网帧到达DNS服务器，DNS服务器通过对比目的地址，从而抽取到DNS查询报文，在它的DNS缓存数据库中查找该主机名所对应的IP地址。DNS服务器生成包含这个IP地址的DNS回答报文并发给请求主机。最终主机通过从DNS报文中抽取出需要请求网页web服务器的IP地址。</li><li>通过三次握手建立连接：有了目的地址的IP地址后，他能够生成TCP套接字。该套接字将用于向目的web网址发送HTTP请求报文。客户端必须先与服务器的TCP程序执行三次握手。客户端生成一个具有目的端口80（针对HTTP）的TCP SYN报文段，该报文段放置在具有目的IP地址为服务器IP地址的IP数据报中。数据报放置在MAC地址为网关路由器的帧中，并通过网关路由器发送该帧。路途中各个路由器通过转发表确定该帧的下一跳路由器。数据报最终到达服务器。服务器抽取TCP SYN报文并分解到端口80相连接的欢迎套接字，对于服务器和客户端之间的TCP连接生成一个连接套接字。产生一个TCP SYNACK报文段，通过套接字将其发往客户端。ACK报文最终到达客户端。IP数据报在操作系统中分解到上面生成的TCP套接字，从而进入连接状态。借助于该套接字，客户端浏览器可以生成获取URL的HTTP报文。HTTP报文则写入套接字。TCP报文则承载HTTP报文，生成一个IP数据报，最后封装成帧发送给服务器。服务器读取HTTP请求报文，将生成HTTP响应报文，将请求的Web网页内容放入HTTP响应体，并将报文放入TCP套接字。客户端收到报文后从套接字中读取HTTP响应，从响应体中抽取Web页面，并渲染最终得到用户眼中的网页</li></ol><h2 id="http缓存" tabindex="-1">http缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;http缓存&quot;">​</a></h2><p>区别： 强缓存命中，不会请求服务器，直接请求缓存；协商缓存命中，会请求服务器，不会返回内容，然后读取缓存； 过程：强缓存( 服务返回Cache-Control: HTTP1.1指定资源过期时间，Expires: HTTP1.0 服务器时间 )、协商缓存(服务返回Etag 和 Last-Modified秒级不及时)</p><ul><li><p>浏览器第一次加载资源，返回 200，浏览器从服务器下载资源文件并缓存资源文件与 response header包含Cache-Control，供下次加载时对比使用；</p></li><li><p>下次加载资源时，浏览器比较 Cache-Control的max-age或Expires判断是否命中强缓存。如果命中 不会请求服务器</p></li><li><p>没命中强缓存，也就是max-age=xxx 过期或值为no-cache，向服务请求带上If-None-Match：Etag/If-Modified-Since： Last-Modified判断是否命中协商缓存，服务用 Etag/If-Modified-Since:判断被请求文件是否修改，304/200+新资源+新Etag <img src="/network/http.png" alt="http.png"></p></li></ul><p>注意：</p><ul><li><p>memory cache和disk cache都是强缓存不请求服务, 一般图片对应 memory cache，css资源 disk cache，js资源可能是 memory cache或disk cache；</p></li><li><p>静态资源html、js、css、图片用强缓存，如果更新版本的话，静态资源一般都是带hash的，hash变了会重新请求，没变就用强缓存，打包css js文件加时间戳/版本号，让浏览器认为请求不同文件，会重新下载；vite中三方依赖都是强缓存，保证每次代码更新时不额外请求依赖库代码；</p></li><li><p>html设cache-control:max-age=0/no cache表强缓存失效，立即发请求，并在服务端验证是否要更新缓存也就是协商缓存。如果过期，则从服务端重新获取资源，否则从缓存中获取。html的meta标签可设。html 业务数据不缓存</p></li><li><p>现在常见的打包工具已经做了协商缓存，根据hash判断文件变化，所以不需要浏览器协商缓存，而且如果服务器要考虑负载平衡问题，多个服务器资源的 Last-Modified 应一致，因为每个服务器上 Etag 值不一样，因此负载平衡时，最好不设 Etag。</p></li><li><p>Cache-Control</p><ul><li>public：可被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。不常用，一般用max-age</li><li>private：只能被用户浏览器缓存，不允许任何代理服务器缓存。实际开发中，对于含有用户信息的HTML，通常设这个字段值，避免代理服务器(CDN)缓存；</li><li>no-cache：不用强缓存，转协商缓存请求服务端，客户端可缓存内容，但是否用缓存要经过协商缓存决定，相当于max-age=0，用于不加hash的静态资源如index.html,本地可以缓存，但是必须经过服务器验证</li><li>no-transform:不能随便改动缓存内容</li><li>no-store：禁止任何缓存，每次都请求；比no-cache优先级高</li><li>max-age=：缓存最大有效期，秒；</li><li>s-maxage=：优先级高于max-age=，仅用于共享缓存(CDN)，优先级高于max-age或Expires；</li><li>max-stale[=]：客户端愿意接收已经过期资源，但不能超过给定时间限制。一般只需设置一种就可以实现强缓存，两种一起用，Cache-Control 优先级高,max-age到期后，已经缓存内容的有效期，发起端设置</li><li>must-revalidate缓存到期后必须在源服务端发请求重新获取数据验证是否真的过期，不能直接用本地缓存</li><li>proxy-revalidate 缓存服务器</li></ul></li><li><p>优缺点 减少冗余数据传输，节省网络费用，缓解网络瓶颈，节省带宽能更快加载页面。 降低对原始服务器的要求，更快地响应，避免过载出现。降低距离时延，因为从较远的地方加载页面会更慢一些。 缺点：缓存中的数据可能与服务器的数据不一致；消耗内存； 不推荐用 Expires 首部，它指定实际的过期日期不是秒数。很多服务器的时钟不同步，最好用剩余秒数，而不是绝对时间来表示过期时间。 ETag解决了Last-Modified使用时可能出现的资源的时间戳变了但内容没变及如果再一秒钟以内资源变化但Last-Modified没变的问题，感觉ETag更加稳妥。 补充：根据浏览器缓存策略，Expire和Cache-Control用回车、后退、F5刷新会跳过本地缓存，每次都会从服务器中获数据。</p></li></ul><h2 id="websocket" tabindex="-1">websocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;websocket&quot;">​</a></h2><p><img src="/websocket.jpg" alt="websocket"></p><h2 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h2><p>传输层已经提供完整的通信服务，应用层只负责对接用户定义应用间通信规则，包括软件协议、传输层协议TCP UDP。web应用服务之间通信要遵循的协议 应用进程的报文：请求/应答报文、报文格式、应用进程发送数据的时机和规则 UDP：不可靠，注重实时性，无连接 TCP：可靠性传输</p><p>DNS 53 udp 域名系统(53 tcp+udp) 传输层：IP+PORT 可以唯一指定目标主机IP的进程进行数据传输。每一个网络进程就是一个服务，比如web服务Nginx进程端口默认是80，那么一个主机上可能会有多个服务(进程/端口)，记不住，所以有了DNS域名系统做IP和域名的映射，我们只需记住域名就行，通过域名请求DNS服务拿到IP，然后再请求IP对应的服务 域名：点、字母、数字组成，点分割不同的域，域名分为顶级域、二级域、三级域。 ping xxx 返回域名对应的IP 域：代表网络段；名：IP对应的名称 DNS 是基于 UDP 做的查询。</p><p>为什么出现：IP很多记不住，所以出现DNS服务记录IP对应的域名，人只需要记住域名通过浏览器访问，DNS服务将域名转为IP返回给浏览器，浏览器再请求IP对应的服务。DNS服务器遍布在各大运营商：电信 移动 联通，局域网会安装路由，局域网内的终端请求IP会通过路由网关转发到互联网中ISP，ISP之间会有联系 查找过程： 根域名服务器知道所有顶级域名服务器地址，顶级域名服务器主要由国家维护，地区域名服务器主要由机构 公司维护。 www.taobao.com从右到左顶级域、二级域、三级域依次查找</p><ol><li>浏览器的缓存中查找对应的IP地址</li><li>浏览器向本地host文件查询dns缓存</li><li>向本地dns服务器发起递归请求，本地dns服务器可以理解为路由网关，路由上由IP映射表。ipconfig/all 查看DNS服务器地址。DNS服务器在ISP(互联网服务提供商)的服务器上，它们会给用户发路由器，请求DNS服务器也就是请求到了网关路由器，DNS服务器地址是通过DHCP协议自动分配的，后面有 DHCP是一种用于动态分配IP地址的协议</li><li>本地dns服务器依次向根域名服务器，顶级域名服务器，权威域名服务器发迭代请求，拿到IP返给客户端</li><li>客户端浏览器拿着IP请求对应的服务</li></ol><p>分类：查找过程不是数组数据结构全部遍历，而是从右往左分级查找 // DNS树形结构示例 const dnsTree = { // 根域名服务器 name: &quot;root&quot;, // 顶级域名服务器 children: { com: { name: &quot;com&quot;, // dns映射列表 children: { example: { name: &quot;example.com&quot;, ip: &quot;93.184.216.34&quot;, // 这里直接存放IP地址 }, google: { name: &quot;google.com&quot;, ip: &quot;216.58.200.14&quot;, }, // 其他.com域名 }, }, net: { name: &quot;net&quot;, children: { // ... 其他.net域名和它们的IP }, }, // 其他顶级域名 }, };</p><p>// 辅助函数：在DNS树中查找域名 function findInDnsTree(domainParts, tree, currentIndex = 0) { // domainParts域名分割后的数组 [com,example] if (currentIndex === domainParts.length) { return tree.ip || null; // 如果到达叶节点，返回IP或null（如果未找到） } // 当前查找的树的层级 const currentPart = domainParts[currentIndex]; // tree[com] 三级域名下的dns映射列表 const childTree = tree.children[currentPart]; //如果存在继续递归</p><p>if (childTree) { return findInDnsTree(domainParts, childTree, currentIndex + 1); // 递归查找下一个部分 } else { return null; // 如果在当前级别找不到对应的子树，返回null } }</p><p>// 使用示例 const domain = &quot;example.com&quot;; const domainParts = domain.split(&quot;.&quot;).reverse(); // 反转域名部分以便从根开始查找 const ipAddress = findInDnsTree(domainParts, dnsTree); console.log(<code>The IP address for ${domain} is: ${ipAddress}</code>); （1）区域传输TCP辅域名服务器定时向主域名服务器查询数据是否变动。如变动，执行区域传送数据同步。数据同步传送数据量比一个请求应答的数据量多得多。 （2）域名解析UDP客户端向DNS服务器查域名，返回内容不超512字节，UDP不用三次握手，DNS服务器负载低，响应快。理论上可指定查询时用TCP，事实上很多DNS服务器配置时仅支持UDP查询包。 递归：客户端只发一次请求，要求对方给出最终结果。 迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表， 客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。 授权回答：向dns服务器查询一个域名，刚好这个域名是本服务器负责，返回的结果就是授权回答。 从递归和迭代查询可以看出： 客户端-本地dns服务端：这部分属于递归查询。 本地dns服务端(路由网关)---外网：这部分属于迭代查询。 递归查询时，返回的结果只有两种:查询成功或查询失败. 迭代查询，又称作重指引,返回的是最佳的查询点或者主机地址.</p><p>DHCP 67 udp 动态主机设置协议，工作在局域网内是局域网协议，基于UDP传输 回顾： IP分类：广域网、域域网、局域网 局域网分三类，局域网通过NAT，路由网关将内网的IP地址转化为外网IP地址进行通信 作用： 每个终端接入互联网都要配IP地址，如果设备使用了DHCP协议会自动配置也就是即插即用，比如：电脑的自动获取IP地址就是启用DHCP协议，临时分配一个IP一般都是内网地址然后结合NAT技术进行网络连接</p><p>新设备怎么知道自己的IP DHCP监听67端口，新主机用UDP协议广播(我需要IP)，找到DHCP服务的IP地址，UDP位于IP协议之上，主机这时候没有IP，广播的时候报文全填1表明当前是广播报文，DHCP服务器收到广播报文后回应一个提供报文附上IP地址(我可以生成)，主机收到提供报文消息后，向DHCP服务发出请求报文，DHCP回应提供IP地址</p><p>HTTP 80 tcp Web服务（nginx）就是一个提供内容的服务，内容可以是超文本html文件，而请求超文本内容就需要遵循超文本传输协议http，这些内容在web服务器上都有统一的存放地址。</p><ol><li>请求的时候通过http(https)😕/主机ip 域名：端口/path</li><li>端口默认是80/443，path默认是/</li><li>基于TCP实现，是可靠数据传输协议，数据包含图片 文本 音视频</li><li>基于典型的CS架构，客户端(手机 浏览器) 服务端(web服务器 nginx Apache) 之间通过http协议传输</li><li>web服务器分硬件和软件，硬件：计算机/云虚拟服务器；软件：nginx Apache Web服务器如何连接并处理</li><li>发布域名和端口，端口默认80，接收客户端连接</li><li>接收请求报文</li><li>处理请求</li><li>访问并获取web资源</li><li>构造应答报文并返回 特点：简单快速，只传方法和路径、无连接无状态、灵活 传任何类型的数据 缺点：无状态，明文 性能：基于 TCP/IP，通信模式是请求-应答。 版本差异 0.9 只支持get，无http头，只能传html文件，无状态码和错误代码，服务器发完就关闭TCP连接。 1.0 添加状态码，http头，加入content-type属性，除了传输html还能传输其他类型文档。每次1请求重新建立1连接。服务器发送完毕就关闭TCP连接。 1.0-1.1 短连接------长连接(管道网络传输、队头阻塞、默认Connection： keep-alive) Expires/If-Modified-Since-----catch-control/If-None-Match 全传----range域断点续传 get post-----delet put option 无host-----请求头host服务器域名 说明 短连接：一个请求一个tcp，串行请求，开销大。可 Connection: keep-a live 不关闭 TCP 连接。 长连接：TCP 复用，避免三次握手，一个域同时 6 个持久连接，无序发送按序返回，可能队头阻塞。 管道网络传输：同一 TCP并行发多个请求，减少整体响应时间。但服务器还是按序响应。如果前面响应慢，会队头堵塞(长连接多路复用，并发的所有请求放一个任务队列中串行执行，若队首请求处理慢，就会阻塞) 请求头host：1.0 认为每台服务器绑定唯一IP，因此请求的 URL 没有传主机名（hostname）。现在一台物理服务器可存在多个虚拟主机，它们共享一个IP。因此host 字段，将请求发往到同一台服务器上的不同网站。 解决队头阻塞：并发连接：一个域名允许分配多个长连接，增加任务队列，不至于一个队伍任务阻塞其它所有任务。域名分片：域名分很多二级域名指向同一台服务器，能并发的长连接数变多。 1.1-2.0 1.1 2.0 3.0 浏览器限制同⼀个域名下的请求数量,最多6个，长连接复用 ,按序返回 队头堵塞，多个请求复用一个tcp连接 请求头Connection:keep-alive 响应头Keep-Alive:timeout-5 多路复用 keep alive无序返回，避免队头堵塞，每个请求或回应的所有数据包称一个数据流。每个数据流有位移id，所有数据流共用一个连接，一个丢包会阻塞。 UDP传输 解析基于文本 解析基于二进制帧 无状态，⽂本形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输⼏百到⼏千的字节。 头信息gzip或compress压缩，降低开销（发差异部分）,双方维护一张头信息表，所有字段存入该表，生成索引号，以后只发索引号，提高速度。 服务器推送：推送静态资源，和 WebSocket 及 SSE 发即时数据的推送不同。浏览器兼容的情况下你也可以使⽤ prefetch 。 html文件中css和js文件都是链接方式显示，浏览器解析内容后再根据链接url地址请求对应的文件。 改进：请求html同时，将里面引用的文件推送至客户端。串行改为并行。 cache-control强缓存 eTag协商缓存 host请求 使不同域名配置在同一个IP地址的服务器上 响应分块 请求头Range:bytes=xxx；单个请求可以返回部分内容 响应头Content-Range:bytes 0-xxx表示返回哪部分内容，状态206 管道化技术pipeline：可以连续发多个请求，不用等待返回就可以被发送，减少耗费网络延迟时间，类似并发 2.0 重要的概念，帧（frame）和流（stream）。 帧代表最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极⼤的提⾼传输性能。 QUIC 这是⼀个⾕歌出品的基于 UDP 实现的同为传输层的协议，⽬标很远⼤，希望替代 TCP 协议。 该协议⽀持多路复⽤，虽然 HTTP 2.0 也⽀持多路复⽤，但是下层仍是 TCP，因为 TCP的重传机制，只要⼀个包丢失就得判断丢失包并且重传，导致发⽣队头阻塞的问题，但是UDP 没有这个机制 实现了⾃⼰的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已 经实现了 0-RTT 了 ⽀持重传和纠错机制（向前恢复），在只丢失⼀个包的情况下不需要重传，使⽤纠错机制 恢复丢失的包 纠错机制：通过异或的⽅式，算出发出去的数据的异或值并单独发出⼀个包，服务端 在发现有⼀个包丢失的情况下，通过其他数据包和异或值包算出丢失包 在丢失两个包或以上的情况就使⽤重传机制，因为算不出来了 3.0 可靠性：用共享密钥进行加密和认证，及用安全算法防止攻击和中间人攻击等。UDP本身并不提供安全保障，要在应用层用TLS/SSL安全机制进行加密和认证，SSL 证书是数字证书，用于认证网站的身份并启用加密连接。SSL 代表安全套接字层，是安全协议，可在 Web 服务器和 Web 浏览器之间创建加密连接。CA 是证书颁发机构，由 CA 机构颁发的证书都可以成为 CA 证书，SSL 证书只是 CA 机构颁发证书的其中一种。 基于UDP的安全可靠的2.0协议。QUIC协议 udp实现：避免三次握手，TLS1.3减少握手花费的RTT数； 保留2.0多路复用，但即使多路复用过程中，同一TCP连接上有多个stream，假如其中一个stream丢包，重传前后续的stream都会影响，而QUIC中一个连接上的多个stream之间没有依赖。所以当丢包时，只会影响当前的stream，也就避免了阻塞。多路复用，解决2.0中前一个丢包导致后一个阻塞问题；一个流维护一个滑动窗口。<a href="https://blog.csdn.net/weixin_36750623/article/details/126852498" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_36750623/article/details/126852498</a> 优化重传策略：重传包和原包的编号不同，降低后续重传计算的消耗； 以往TCP丢包重传策略是：发送端为每一个封包标记一个编号，接收端收到封包时，回传一个带有对应编号的ACK封包给发送端，告知发送端封包已经确实收到。当发送端在超过一定时间之后还没有收到回传的 ACK，就会认为封包已经丢失，启动重新传送的机制，复用与原来相同的编号重新发送一次封包，确保在接收端这边没有任何封包漏接。 这样的机制就会带来一些问题，假设发送端总共对同一个封包发送了两次 (初始 + 重传)，使用的都是同一个sequence number：编号N。之后发送端在拿到编号N封包的回传ACK 时，将无法判断这个带有编号N的ACK，是接收端在收到初始封包后回传的ACK。这就会加大后续的重传计算的耗时。QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到ACK时，可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。 流量控制： 限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收 buffer，优化记忆体被占用的空间。但是如果存在一个流量极慢的stream ，光一个stream就有可能佔用掉接收端所有的资源。QUIC为了避免这个潜在的HOL Blocking，采用了连线层 (connection flow control) 和 Stream 层的 (stream flow control) 流量控制，限制单一 Stream 可以占用的最大buffer size。 连接迁移： TCP连接基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间。 QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，对应每个stream，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。 连接迁移，不再用tcp四元组确定一个连接，用64位随机数确定连接； cookie session 这两个出现的原因是因为http无状态，不能保存客户端请求信息，每次都要重连接，也就是重新登录 cookie 在请求头中 保存用户信息 一般把token存在cookie中 sesion 在服务端保留客户信息 设置有效期 流程： 客户端调login接口，服务端创建token返回唯一token，并设置该token有效期 客户端收到token就存到cookie中，后续每次发请求都带上cookie 服务端拿到cookie取出里面的token，与自己之前存入session的值对比，如果相同就免登录 cookie每次请求都要向后台发送数据，所以容量要有限制，否则会大大降低网络传输效率。</li></ol><p>HTTPS 443 tcp</p><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。 HTTPS的优点如下：</li></ol><ul><li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li><li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本； HTTPS的缺点如下：</li><li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li><li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li><li>SSL证书是收费的，功能越强大的证书费用越高；</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li><li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进⾏了加密。 缺点： 握手阶段费时，使页面加载时间延长 50%，增加 10%~20%的耗电。https 缓存不如 http 高效，会增加数据开销。 SSL 证书要钱，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ul><p>综合使用了散列函数hash, 对称加密和非对称加密，在传输数据前通过SSL安全参数握手结合CA证书各自生成相同的密钥，后续通过对称加密传输数据。(SSL在传输层实现),，散列函数验证信息的完整性，对称加密算法采用协商的秘钥对数据加密，非对称加密实现身份认证和秘钥协商 散列函数 常见的散列函数有MD5、SHA1、SHA256。该函数特点是单向不可逆，对输入数据敏感，输出长度固定，任何数据的修改都会改变散列函数结果，用于防止信息篡改并验证数据的完整性。 信息传输过程中，散列函数不能都实现信息防篡改，由于明文传输，中间人可修改信息后重新计算信息摘要，所以需要对传输的信息和信息摘要进行加密。</p><p>对称加密和非对称加密，对称加密加解密都是同一个密钥，非对称加密是公钥加密，提前约定加密方式，提前生成密钥。后续发送方都使用密钥进行加密，接收方用同一个密钥对信息进行解密。但是密钥也可能泄漏。所以推荐采用非对称加密，A将公钥发送B，B收到后生成用于对称加密的密钥。 对称加密： 双方有相同的密钥，数据加解密用相同的密钥，用协商的密钥对数据加密摘要算法：验证信息完整性. 如何保证秘钥传输安全性，秘钥通过网络传输，一旦秘钥被他人获取，加密过程就毫无作用了。 这要用到非对称加密的方法。 常见的对称加密算法AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。 非对称加密 有公钥私钥之分，公钥所有⼈都可以知道，可以将数据⽤公钥加密，但是将数据解密必须使⽤私钥解密，私钥只有分发公钥的⼀⽅才知道。 一组有数学关系的密钥，A、B，双方用不同的密钥A或B，公钥加密私钥解密，实现身份认证和密钥协商 密钥A作为私钥自己用，不公开，用于解密数据 密钥B作为公钥公开，用于加密数据 举例：服务端有一组密钥A B，将B公开，所有想向服务端发数据都用公钥B加密，服务端可以用没公开的私钥A解密，这时候服务端将加密的数据发给客户端，客户端咋解密呢？CA证书了解一下 非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。 常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。 特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。 综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。 CA数字证书 现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。 首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。 这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。 可信任组织发给特定对象的认证，对象指用数字证书的对象，组织也要得到客户端服务端双方认可。 客户端具体怎么验证CA证书有效的？浏览器是如何确保CA证书的合法性？ 一、证书包含什么信息？ 颁发机构信息、公钥、公司信息、域名、有效期、指纹…… 二、证书的合法性依据是什么？ 首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。 三、浏览器如何验证证书的合法性？ 浏览器发起HTTPS请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p><ol><li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行校验；</li><li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与CA服务器的交互，提高验证效率。 作用：身份验证 证书中就包含对象的名称和公开密钥，比如：name: 192.168.2.36 key:11111</li></ol><p>安全套接层SSL 位于传输层之上，应⽤层之下，保证数据安全和完整 ，对数据加密..⾸次进⾏ TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到⼀个 RTT。在 TLS 中使⽤了两种加密技术，分别为：对称加密和⾮对称加密。 结合了对称加密和非对称加密保证数据安全传输，非对称加密主要是客户端第一次请求时没有对话密钥，这时候用非对称加密产生对话密钥，产生密钥的过程就是非对称加密，非对称加密是公钥加密私钥解密，服务端提供公钥给所有人也就是所有客户端，客户端用服务端提供的公钥将自己的伪随机数加密请求到服务端，服务端用自己的私钥解密，这时候服务端知道客户端传的伪随机数，客户端也知道自己的伪随机数，后续双方用这个伪随机数作为密钥进行传递。 问题：虽然非对称加密安全性高，但是也可能被中间人劫持，中间人截取服务端公钥并替换为自己的公钥返给客户端，这时客户端拿到的就是假公钥对伪随机数加密，中间人用私钥解密拿到对话密钥，中间人用真正的服务器公钥加密后发给真正的服务器，后续数据传输就变成明文。 解决：为了避免中间人劫持，引入CA证书验证身份，也就是所有服务端站点想用https必须有一个服务端自己的CA证书，客户端第一次请求后拿到服务端公钥不会直接用这个公钥加密，而是验证服务端的CA证书和公钥是否一致，一致的话就用证书中的公钥对随机数加密然后发送，不一致的话浏览器会提示该站点不安全，</p><p>完整流程</p><ol><li>443端口TCP连接</li><li>SSL安全参数握手： a. 客户端生成随机数1，将协议版本号，随机数，可用的加密方法传给服务端 (明文) b. 服务端生成随机数2，将确认加密算法，随机数，自己的CA数字证书(包含公钥)返给客户端 (确定加密算法) c. 客户端检查CA证书，生成随机数3，用服务端CA证书中的公钥加密随机数、内容hash、发给服务端 d. 服务端私钥解密随机数，返回内容hash (双方都有随机数123) e. 三个随机数生成一把秘钥，以后双方通信前，就用这个秘钥对数据进行加密后再传输</li><li>客户端，服务端传输数据 握手时用ECDHE算法密钥交换，RSA签名和身份认证，握手后用AES对称算法，密钥长度256位，分组模式是GCM，摘要算法SHA384用于消息认证和产生随机数。</li></ol><p>扩展 https也不安全，响应数据中途被修改了，比如非会员改成会员，怎么解决？ 思路：客户端收到假的，就要向服务器验证，但是又不能每一个响应都进行确认。https不是加密的吗？ 好像只是加密客户端传给后端的，那就后端也给前端一个对称秘钥？此时面试官点了点头表示满意）CA证书 https抓包分析？ 如何保证安全的？</p><p>先理解两个概念：</p><p>●对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 ●⾮对称加密：</p><p>\1. 私钥 + 公钥= 密钥对</p><p>\2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</p><p>\3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</p><p>\4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</p><p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p><p>解决⽅案：</p><p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p><p>此时⼜带来⼀个问题，中间⼈问题：</p><p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。</p><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。</p><p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 HTTP 和 HTTPS 区别 安全性 端口号 证书 http 80 协议简单，不安全，无状态； https 443 , 要CA证书贵，安全性高用SSL加密传输协议 HTTP 和Websocket区别 1、含义不同 websocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议。 http：超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上，是单向的通信协议。 2、连接方式不同 websocket：WebSocket是需要浏览器和服务器握手进行建立连接的。 http：http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。 3、连接长度不同 websocket：websocket是持久连接。 http：http 是短连接(http可以通过Ajax一直发送请求和长轮询保持一段时间内的连接，但本质上还是短连接)。 4、连接状态不同 websocket：websocket是有状态的双向连接。 http：http 是无状态的单向连接。 5、协议开头不同 websocket：websocket的协议是以 ws/wss 开头。 http：http 对应的是 http/https。 Websocket (80/443 tcp 复用http通道) tcp双向传输+复用http握手通道，无同源限制。持久连接，全双工双向通信，实时性强，支持文本、二进制数据，数据格式轻量，性能开销小，解决半双工通信弊端。特点：服务器和客户端都能主动推消息、 原理：发布订阅模式，先添加订阅event，后续变化了websocket会通知之前订阅过的服务端进行处理。协议标识符 ws（wss） // index.html中直接写WebSocket，设服务端端口号为 9999 let ws = new WebSocket(&#39;ws://localhost:9999&#39;); // 在客户端与服务端建立连接后触发 ws.onopen = function() { console.log(&quot;Connection open.&quot;); ws.send(&#39;hello&#39;); }; // 在服务端给客户端发来消息的时候触发 ws.onmessage = function(res) { console.log(res); // 打印的是MessageEvent对象 console.log(res.data); // 打印的是收到的消息 }; // 在客户端与服务端建立关闭后触发 ws.onclose = function(evt) { console.log(&quot;Connection closed.&quot;); }; websocket(80/443 tcp 复用http通道) 全双工通讯，tcp双向传输+复用http握手通道，能通过各种 HTTP 代理服务器。持久连接 原理：c向 WebSocket 服务器通知（notify）一个带有所有接收者 ID的事件（event），服务器接收后立即通知所有活跃（active）客户端，只有 ID 在接收者 ID 序列中的客户端才会处理这个事件。 特点 全双工，双向通信，实时性强、可发文本、二进制数据、TCP 协议，服务端实现容易 数据格式轻量，性能开销小，通信高效，连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。 无同源限制 协议标识符 ws（wss），服务器网址是 URL HTTP 协议缺陷：通信只能由客户端发起，不具备服务器推送能力。在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。</p><p>短轮询：浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><p>长轮询：c向s请求，s收到后不直接响应，先将请求挂起，判断s端数据是否更新。更新则响应，否则到一定时间限制才返回。c响应处理函数处理完s返回的信息后，再次发请求建连接。减少不必要的 http 请求次数，节约资源。但挂起也会导致资源浪费。</p><p>SSE单向推送：http协议，s无法主动推送信息。但s可向c声明，接下来要发流信息，不是一次性数据包，是数据流，会连续不断地发送。这时c不会关连接，一直等s发来新的数据流，如视频播放。SSE利用该机制，用流信息向浏览器推送信息。除IE/Edge，其他浏览器都支持。无需建立过多 http 请求，节约资源。　SSE 是单向通道，只能服务器向客户端发送消息，如果客户端需要向服务器发送消息，则需要一个新的 HTTP 请求。这对比 WebSocket 的双工通道来说，会有更大的开销。这么一来的话就会存在一个「什么时候才需要关心这个差异？」的问题，如果平均每秒会向服务器发送一次消息的话，那应该选择 WebSocket。如果一分钟仅 5 - 6 次的话，其实这个差异并不大。 websocket: 双向推送 性能：WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询(兼容性相反) 轮询和websocket如何选 实时性高：websocket，更新不频繁，轮询时间又短，大量轮询会造成资源浪费。如果说用websocket,就是在服务端有更新时进行推送，实时性相对更高。即时聊天通信、多玩家游戏、在线协同编辑/编辑、实时数据流拉取与推送、体育/游戏实况、实时地图位置</p><p>实时性不高: 轮询，机械系的用定时器：每5秒拉取，数据在第6改变，那么在下一次轮询第10s才能获取最新数据。比如文件上传的进度条会选择用轮询，当用户同时上传多个文件或多用户，建立的websocket连接数会过多，服务器压力过大。所以轮询更合适,隔几秒查询一次进度就ok，进度条是假的对实时性要求也不高,最后通过flag判断是否上传完成。 轮询比websocket好的例子？ 如：用户登录，实时获取用户信息，轮询比websocket好,隔一段时间更新一次，数据又没怎么变，变化的几率很小 http: 获取旧数据，或只获取一次数据供应用程序使用,仅加载一次数据，RESTful Web服务足以从服务器获取数据。 补充 即时Web应用程序：用一个Web套接字在客户端显示数据，这些数据由服务连续发送。WebSocket中，数据被连续推送/传输到已经打开的同一连接中，如在交易网站显示价格波动，数据被服务用Web套接字通道连续推到客户端。 游戏应用程序：服务器会持续接收数据，不会刷新界面。屏幕上用户界面自动刷新，不需要建立新连接 聊天应用程序：仅用WebSocket建立一次连接，便能在订阅户之间交换，发布和广播消息。重复用相同的WebSocket连接，用于发送和接收消息以及一对一的消息传输。 MQTT tcp CDN内容分发网络 CDN是如何优化静态资源加载速度的。 cdn是什么？缓存</p><p>请求报文 请求行(请求方法，url，协议版本)，请求头，空行，请求体(post put带的数据)</p><p>请求方法 get post put delete put/patch、delete trace、connect head 获取报文首部，与 GET 相比，不返回报文主体部分post put delete options 预检请求 获取server支持的请求方法，CORS 跨域资源共享，复杂请求用 OPTIONS 先发一次，判断是否有权限。返回内容不能缓存。</p><p>204 CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信；1.0不支持长连接 副作⽤：指对服务器上的资源做改变，搜索是⽆副作⽤的，注册是副作⽤的。 幂等：指发送 M 和 N 次请求（两者不相同且都⼤于 1），服务器上资源的状态⼀致，⽐如注册10 个和 11 个帐号是不幂等的，对⽂章进⾏更改 10 次和 11 次是幂等的。 规范的应⽤场景上说，Get 多⽤于⽆副作⽤，幂等场景，如搜索关键字。Post ⽤于副作⽤，不幂等的场景，例如注册。 get post 参数传递方式 url 传递 放在 request body 中 传递参数长度 有限制，浏览器和 web 服务器限制了 URI 的长度，IE最大2083byte，支持 Chrome，则最大长度 8182byte 无 安全 不安全，参数直接暴露在 url 中，且会被浏览器保存历史纪录 相对安全 编码方式 url 编码 多种编码方式 浏览器是否缓存参数 是，完整保留在浏览历史记录里 否，不会被保留。 数据包个数 1个 header 和 data 一并发 2个，复杂请求有一次预检请求，先发送 header，再发data PUT请求是向服务器端发送数据的（与GET不同）从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。 请求头 通用： User-Agent 客户端用的操作系统和浏览器名称，版本。 Authorization 超文本传输协议的认证信息 Connection 客户端（浏览器）想要优先使用的连接类型，close/keep-alive 1.0 没长连接 Host 指定被请求资源的host和port，从URL提取 From 发起此请求的用户的邮件地址 Origin 协议 + 域名 + 端口号,指示请求来自哪个站点，仅指示服务器名称，不包含路径信息，除了不包含路径信息，与 Referer 字段相似，浏览器自动加到http请求Header中。 Referer 告诉服务器从哪个页面链接过来的，服务器可获得一些信息用于处理。 Max-Forwards 限制该消息可被代理及网关转发的次数。 Upgrade 要求服务器升级到一个高版本协议。 Via 告诉服务器，这个请求是由哪些代理发出的。 Pragma 报⽂指令 Transfer-Encoding 传输编码⽅式 Upgrade 要求客户端升级协议 Warning 内容中可能存在错误 Proxy-Authorization 向代理服务器发送验证信息 缓存： if-none-match(etag), if-modified-since(last-modifined), cachectrol, expires， Cache-Control （expires） 用来指定当前的请求/回复中的，是否使用缓存机制。 private：默认，响应只能作为私有缓存，用户间不能共享。 public 响应会被缓存，多用户共享。正常情况如果要求HTTP认证,响应会自动设置为 private。 must-revalidate 响应在特定条件下会被重用，以满足接下来的请求，但必须到服务端验证是否最新的。 no-cache 不缓存,实时请求资源。 max-age=10 缓存最大有效时间，单位秒。 no-store 任何条件下，都不缓存，且不会被写入到客户端的磁盘里，基于安全考虑会用这个。 Cookie 存储用户信息以便辨别身份，登录后在客户端产生cookie存相关信息，这样浏览器通过读取。cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。 if-none-match(etag) 协商缓存，304 if-modified-since(last-modifined) 协商缓存，304 If-Unmodified-Since 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。 发送内容： Content-Length 以 8 进制表示的请求体的长度 Content-Type 请求体的 MIME 类型 （用于 POST 和 PUT ） Content-MD5 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 Date 送该消息的日期和时间（以 RFC 7231 中定义的&quot;HTTP 日期&quot;格式来发送） Content-Encoding 客户端压缩算法</p><p>Content-Type: POST请求，告诉服务发的数据类型。 application/x-www-form-urlencoded 正常的Form表单<br> form-data单独的文件上传 mutipart/form-data文件上传还能传其他信息 multipart/form-data Form 表单的 enctype 设置为multipart/form-data 上传文件，键值对，也可上传文件/多个文件 application/json消息主体是序列化后的 JSON 字符串，JSON 格式支持比键值对复杂得多的结构化数据。 text/xml // 说明：提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据 binary（application/octet-stream） // 说明：用来传输二进制文件类型 接收内容： Accept: text/plain 客户端能接受的res 数据类型 Accept-Charset 可接受的字符集 Accept-Encoding 可接受的响应内容的编码方式。压缩算法 Accept-Language 可接受的响应内容语言列表。 Accept-Datetime 可接受的按照时间来表示的响应内容版本 Range bytes=0-5 // 指定第一个字节的位置和最后一个字节的位置。域请求</p><p>响应报文 响应行(HTTP/1.1 200 OK),响应头,空行,响应体200 OK</p><p>响应码 1xxx 服务器收到请求正在处理 2xx请求成功，请求正常处理完毕 3xx需要进行附加操作一完成请求 4xxx 服务器无法处理请求,客户端错误 5xx 服务器处理请求出错 100 Continue 继续。客户端应继续其请求 101 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议,websocket 200 OK 请求成功。一般用于 GET 与 POST 请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原 始的服务器，而是一个副本 204 请求成功，响应报文不含实体的主体部分，场景：options预检请求只返回头，前端错误监控上报，性能上报，后端返回204节省带宽，埋点信息告诉后端，后端只返回204,,,比如跨域资源共享, 客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。 205 请求成功，响应报文不含实体的主体部分，要求请求方重置内容.,用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 范围请求,服务器成功处理了部分 GET 请求，比如响应分块返回部分内容 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特 征与地址的列表用于用户终端（例如：浏览器）选择 302是http1.0协议状态码，http1.1时为了细化302⼜出来303和307。 303明确表示客户端应当采⽤get⽅法获取资源，会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。 301 永久重定向，配合location新地址，浏览器自动处理，换域名，老域名返回301,今后任何新的请求都应使用新的 URI 代 302 临时重定向，配合location新地址，浏览器自动处理,之前访问过该地址，浏览器有缓存，所以返回200，没访问过应该是302,,服务端返回302和一个location，浏览器会自动跳到该location,, 使用场景：</p><ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。 303 资源存在另一个 URL，用 GET 和 POST 请求查看 304 服务允许访问资源，未修改有缓存,协商缓存,搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。 产生较多304状态码的原因：</li><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html 304状态码出现过多会造成以下问题：</li><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的 HTTP 状态码 307 临时重定向，和 302 类似，期望客户端保持请求方法不变向新地址发请求,不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。 308永久重定向(带参数) 400 请求报文语法错误 401 发的请求要有通过 HTTP 认证的认证信息 403 请求资源的访问被服务器拒绝，没登录，没有角色权限</li><li>403.1 - 执行访问被禁止。</li><li>403.2 - 读访问被禁止。</li><li>403.3 - 写访问被禁止。</li><li>403.4 - 要求 SSL。</li><li>403.5 - 要求 SSL 128。</li><li>403.6 - IP 地址被拒绝。</li><li>403.7 - 要求客户端证书。</li><li>403.8 - 站点访问被拒绝。</li><li>403.9 - 用户数过多。</li><li>403.10 - 配置无效。</li><li>403.11 - 密码更改。</li><li>403.12 - 拒绝访问映射表。</li><li>403.13 - 客户端证书被吊销。</li><li>403.14 - 拒绝目录列表。</li><li>403.15 - 超出客户端访问许可。</li><li>403.16 - 客户端证书不受信任或无效。</li><li>403.17 - 客户端证书已过期或尚未生效</li><li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li><li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li><li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。 404 服务没找到请求的资源,可以在服务器端拒绝请求且不想说明理由时使用</li><li>404.0 -（无） – 没有找到文件或目录。</li><li>404.1 - 无法在所请求的端口上访问 Web 站点。</li><li>404.2 - Web 服务扩展锁定策略阻止本请求。</li><li>404.3 - MIME 映射策略阻止本请求。 405请求方法不支持,客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下 Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与 401 类似，但请求者 应当使用代理进行授权 408请求超时; 409请求格式不正确; 410请求需要用户验证;</li><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用 411长度必需满足要求; 413请求实体太大; 414请求的URI太长; 415未满足前提条件,服务器无法处理请求附带的媒体格式; 416未满足范围要求; 417期望失败,服务器无法满足 Expect 的请求头信息; 422未满足要求; 429太多重定向; 431请求头字段过大; 451请求的资源被永久删除; 500 服务执行请求时错误。也有可能是 Web 应用存在的 bug 或某些临时的故障 501 服务不支持当前请求所需要的某个功能 502网关错误 503 无法处理请求、服务器不可用,服务器停机维护,nginx 设置限速 504 网关超时; 服务器之间处理超时 ,HTTP 1.1中新加入的 505不支持的HTTP版本; 506虚拟主机被配置禁止访问; 507服务器错误; 511网络读取超时; 599网络连接被关闭 响应头 Accept-Ranges 是否⽀持某些种类的范围 Age 资源在代理缓存中存在的时间 ETag 资源标识 Location 客户端重定向到某个 URL Proxy-Authenticate 向代理服务器发送验证信息 Server 服务器名字 WWW-Authenticate 获取资源需要的验证信息 Access-Control-Allow-Origin: 所有网站可跨域资源共享/ 指定源， Access-Control-Allow-Credentials不能为truew Access-Control-Allow-Methods：GET, POST, OPTIONS // 允许方法访问。 Access-Control-Allow-Credentials: true // 是否允许发cookie。默认Cookie不包括在CORS请求中。true表示服务器许可Cookie包含在请求中。这个值只能设为true或删除该字段。如果access-control-allow-origin*，当前字段就不能为true。 Cache-Control: private // 默认,响应只能私有缓存，不能共享 Cache-Control: public // 浏览器和缓存服务器都可以缓存页面信息。 Cache-Control: must-revalidate // 客户每次请求，代理服务器必须向服务器验证缓存是否过时。 Cache-Control: no-cache // 浏览器和缓存服务器都不应该缓存页面信息。 Cache-Control: max-age=10 // 强缓存多少秒后到期 Cache-Control: no-store // 请求和响应信息都不应存在对方磁盘系统中。 Content-Type：text/html;charset=UTF-8 // 告诉资源文件的类型，字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。乱码就是服务端没返回正确编码。 Content-Encoding: gzip 告诉客户端服务端发送的资源采用gzip编码，客户端看到这个信息后，应采用gzip对资源解码。 Date: 服务端发资源时的服务器时间，GMT格林尼治所在地的标准时间。http协议发时间都是GMT的。Server：Tengine/1.4.6 // 告诉客户端服务信息。 Transfer-Encoding：chunked // 服务发资源是分块发送。一般分块发的资源是服务动态生成的，不知道资源大小，所以用分块，每块独立，能标示自己的长度，最后一块是0长度，当客户端读到0长度的块时，就确定资源已传完。 Expires:这个时间前，直接访问缓存，客户端和服务器时间不一定相同，没有Cache-Control：max-age=*响应头准确Connection：keep-alive 为回应客户端 Connection：keep-alive，告诉客户服务的tcp连接也是长连接，客户端可继续用这个tcp连接发http请求。 ETag: hash值根据文件内容生成判断文件是否改变，跟Last-Modified差不多。 Refresh: 5; url=<a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a> 重定向，当新资源被创建时。默认5秒后刷新重定向。 实体字段 Allow 资源的正确请求⽅式 Content-Encoding 内容的编码格式 Content-Language 内容使⽤的语⾔ Content-Length request body ⻓度 Content-Location 返回数据的备⽤地址 Content-MD5 Base64加密格式的内容 MD5检验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 Restful API 传统：每个url当作一个功能 现在：每个url当唯一资源标识，不用url参数，用methods表示操作类型</li></ul><p>传输层 判断数据传给计算机的哪个进程，端到端通信，向高层屏蔽的下层通信细节</p><p>网络层解决虚拟网络中路由数据走向问题 传输层解决端到端，客户端和服务端之间通信，进程之间通信，进程分为单机中的进程和跨网络跨设备之间进程，一个计算机可运行多个进程，为了识别目标主机的具体进程要用端口 都属于TCP/IP协议族</p><p>端口 16bit位，0-65535，为了识别计算机中的进程 UDP 用户数据报协议：数据报指从应用层传过来完整的数据，UDP不处理直接封装交给网络层作为IP数据报的数据 发送端，应⽤层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加⼀个 UDP 头，标识下是 UDP 协议，然后就传递给⽹络层了，在接收端，⽹络层将数据传递给传输层，UDP 只去除 IP 报⽂头就传递给应⽤层，不会任 何拼接操作</p><p>UDP首部 这里位是bit，4字节 首部包括4部分：源端口号、目的端口号、UDP长度、UDP校验和 通过端口号找进程 UDP最小长度是8，1字节 头部相比TCP更简单</p><p>UDP特点 无连接、不可靠、面向报文传输，不处理数据、无拥塞控制、首部开销比较小8字节 一对一，一对多，多对多，多对一的方式，提供单播，多播，广播的功能。 面向报文：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 不可靠：通信不需要建立连接，想发就发。收到什么数据就什么数据，不备份数据，发送数据也不会关心对方是否已经正确接收到数据了。再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制 头部开销小，传输数据报文时是很高效的。： UDP 头部包含了以下几个数据：</li><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误 因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。 TCP 传输控制协议</li></ul><p>特点：</p><ol><li>面向连接：发数据前必须两端建立连接“三次握手”，为数据的可靠传输打下了基础。</li><li>可靠传输：对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</li><li>点对点 一对一通信：不支持多播和广播</li><li>全双工通信(双方可同时收发数据)、</li><li>面向字节流：不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li><li>提供拥塞控制：网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</li><li>提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS） 不像UDP直接封装，而是把应用层数据分割成字节流，一部分一部分处理依次放入TCP数据报传输，可能对应用层数据块合并或拆分后进行传输</li></ol><p>TCP首部分析 固定20字节，每行4字节，32bit</p><p>序号Sequence number，：32bit、范围 0-2^32-1；面向字节流，每个字节有一个序号，代表首字节序号，对端可以通过序号顺序的拼接报⽂ 确认号Acknowledgement Number 32bit、范围 0-2^32-1；面向字节流，每个字节有一个序号，期待下次收到的首字节序号，同时也表示上⼀个序号的数据已经收到 比如：序号是501，已经收到100字节，下次期望首字节序号就是601</p><p>数据偏移：占4bit位，表示范围0-15，单位32位字，也就是1=4字节偏移，最大是4x15=60字节，代表真实数据偏离首部的距离，可以退出TCP首部范围在20-60字节 TCP标记：占6bit位，三次握手 四次挥手会用到</p><p>窗口Window Size，：占16bit位，范围0-2^16-1，指明对方可发送多少字节的数据量，单位是字节，滑动窗口 窗口可以结合确认号计算，确认号是501表示500之前都收到了。窗口是1000，表明501-1500都可以接收。⽤于流量控制 紧急指针：指定紧急数据在报文中的位置，前提 URG=1 TCP选项：最多40字节 可靠传输原理 (ARQ协议) TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。 TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。 接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。 发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。 但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停⽌等待 ARQ 和连续 ARQ 缺点：传输效率低，在良好的⽹络环境下每次发送报⽂都得等待对端的 ACK 。</p><ul><li>停止等待ARQ协议 称简单的可靠传输协议，将计算机分为发送方和接收方(TCP是全双工协议，每个计算机可以为发送方也可以是接收方，这里只是为了举例)，一发一收，双方都会等待，收到对方的消息后才会继续通信，超过一定时间还没收到发送的消息或接收确认的消息就超时重传；每发送一个消息就会设置超时定时器，缺点是：一直等待回应对信道(光纤)利用率不高。 停止：发送方发完消息后会停止生成消息，等收到对方的确认消息才会继续生成消息 等待：接收方没有收到消息会一直等待 分三种情况：</li></ul><ol><li>无差错：双方都会等待，收到对方的消息后才会继续通信，只要 A 向 B 发送⼀段报⽂，都要停⽌发送并启动⼀个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下⼀段报⽂。</li></ol><p>报⽂丢失或出错时：每发一个消息就设置超时定时器(TCP中有四个定时器)记录时间，超时重传机制保证了停止等待协议可靠传输，</p><ol><li>发送方的消息丢失了</li><li>接收方的确认消息丢失了</li><li>接收方的确认消息没有在规定时间内到达而是晚到了 报⽂传输的过程中可能丢包。这时超过定时器设的时间会再次发送丢包的数据直到对端响应，所以要每次都备份发送的数据。即使报⽂正常的传输到对端，也可能出现在传输过程中报⽂出错的问题。这时候对端会抛弃该报⽂并等待 A 端重传。 PS：⼀般定时器设定的时间都会⼤于⼀个 RTT 的平均时间。 ACK 超时或丢失 对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报⽂。这时候 B 端收到相同序号的报⽂会丢弃该报⽂并重传应答，直到 A 端发送下⼀个序号的报⽂。 在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</li></ol><ul><li><p>连续ARQ协议 Automatic Repeat reQuest 自动重传请求 自动重传请求，之前单个发送和确认效率低，现在改为批量发送和确认，发送端拥有⼀个发送窗⼝，发一组字节流，收到几个字节窗口就向后移动几个，单位是字节，称为连续滑动窗口，不需要对每个报文都确认而是累计确认，比如收到5，说明5之前都收到了，直接移动窗口就行。可以在没有收到应答的情况下持续发送窗⼝内的数据，这样相⽐停⽌等待 ARQ 协议来说减少了等待时间，提⾼了效率。<br> 原理上：减少确认报文的数量，提高传输效率。</p></li><li><p>TCP协议可靠传输 基于连续ARQ协议：滑动窗口、累计确认、 累计确认 连续 ARQ 中，接收端会持续不断收到报⽂。如果和停⽌等待 ARQ 中接收⼀个报⽂就发送⼀个应答⼀样，就太浪费资源了。通过累计确认，可以在收到多个报⽂以后统⼀回复⼀个应答报⽂。报⽂中的 ACK 可以⽤来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。 但是累计确认也有⼀个弊端。在连续接收报⽂时，可能会遇到接收到序号 5 的报⽂后，并未接到序号 6 的报⽂，然⽽序号 7 以后的报⽂已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下⽂说到。</p></li></ul><p>滑动窗⼝ 在上⾯⼩节中讲到了发送窗⼝。在 TCP 中，两端都维护着窗⼝：分别为发送端窗⼝和接收端窗⼝。 发送端窗⼝包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p><p>发送端窗⼝是由接收窗⼝剩余⼤⼩决定的。接收⽅会把当前接收窗⼝的剩余⼤⼩写⼊应答报⽂，发送端收到应答后根据该值和当前⽹络拥塞情况设置发送窗⼝的⼤⼩，所以发送窗⼝的⼤⼩是不断变化的。 当发送端接收到应答报⽂后，会随之将窗⼝进⾏滑动</p><p>滑动窗⼝实现了流量控制。接收⽅通过报⽂告知发送⽅还可以发送多少数据，从⽽保证接收⽅能够来得及接收数据。 Zero 窗⼝ 在发送报⽂的过程中，可能会遇到对端出现零窗⼝的情况。在该情况下，发送端会停⽌发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗⼝⼤⼩。在重试次数超过⼀定次数后，可能会中断 TCP 链接。</p><p>TCP滑动窗口以字节为单位 举例：设滑动窗口大小为7，一次传7个字节，窗口前面的是已确认的字节序号，后面是不允许发送的字节序号，滑动窗口的第一个是对方期待的字节序号也就是TCP首部的确认号</p><p>前四个已发送未确认，后面3个是可用窗口、只有收到前四个确认的才能将窗口前移</p><p>其他情况：某一时刻，收到中间个别字节的确认号，23 24没收到，不能推动窗口，超时定时器到时间后还是要从23重传。没有按序收到确认号要重传，这样效率低</p><p>所以，要选择重传：TCP选择中包含重传的区间，指定每个字节的唯一32位序号，区间放在TCP选项中最多存10个序号，</p><p>流量控制 （滑动窗口） 通过滑动窗口控制对方发送速率 一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><p>比如：发送方第一次发100字节，第二次就是101开始，接收方返回确认消息ack代表期望收到的下一个字节的序号，rwnd代表发送方还能发送多少数据。</p><p>当接收方把数据给应用层后，窗口就会空闲，告诉发送方可以发数据，但是窗口变化的消息如果丢失，发送方会一直等待窗口调整的消息，接收方也一直等消息，造成死锁，这时会用到坚持定时器，（之前有个超时定时器），接收方收到rwnd=0后启动坚持定时器，每隔一段时间发送窗口探测报文</p><p>拥塞控制 （慢启动） 流量控制作用于发送方，拥塞控制作⽤于接收⽅，保证接收⽅来得及接受数据。⽽前者是作⽤于⽹络，防⽌过多的数据拥塞⽹络，避免出现⽹络负载过⼤的情况。拥塞处理包括了四个算法，分别为：慢启动，拥塞避免，快速重传，快速恢复。 数据从发送方到接收方会经过多个路由器，每个路由器性能不同，和物理层光纤性能有关。 流量控制：点对点 端到端 拥塞控制：全局网络，判断网络整体有没有拥塞 报文超时认为可能网络拥塞，也可能光纤断了 慢启动算法</p><ul><li>由小到大逐渐增加发送的数据量</li><li>每收到一个报文确认，加一：第一次发1个报文，确认后加一，第二次发2个报文... 2 4 8不断指数增长到慢启动阈值，开始调用拥塞避免算法 慢开始算法步骤具体</li><li>连接初始设置拥塞窗⼝（Congestion Window） 为 1 MSS（⼀个分段的最⼤数据量）</li><li>每过⼀个 RTT 就将窗⼝⼤⼩乘⼆</li><li>指数级增⻓肯定不能没有限制的，所以有⼀个阈值限制，当窗⼝⼤⼩⼤于阈值时就会启动拥塞避免算法。</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) <ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法 拥塞避免算法</li></ul></li><li>未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:</li><li>判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li><li>维护拥塞窗口变量，大于慢启动阈值</li><li>只要网络不拥塞也就是报文不超时，就将窗口调大 +1 每过⼀个 RTT 窗⼝⼤⼩只加⼀，这样能够避免指数级增⻓导致⽹络拥塞，慢慢将⼤⼩调整到最佳值。 在传输过程中可能定时器超时的情况，这时候 TCP 会认为⽹络拥塞了，会⻢上进⾏以下步骤：</li><li>将阈值设为当前拥塞窗⼝的⼀半</li><li>将拥塞窗⼝设为 1 MSS</li><li>启动拥塞避免算法</li></ul><p>快速重传 快速重传⼀般和快恢复⼀起出现。⼀旦接收端收到的报⽂出现失序的情况，接收端只会回复最后⼀个顺序正确的报⽂序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，⽆需等待定时器超时再重发⽽是启动快速重传。具体算法分为两种： TCP Taho 实现如下 将阈值设为当前拥塞窗⼝的⼀半 将拥塞窗⼝设为 1 MSS 重新开始慢开始算法 TCP Reno 实现如下 拥塞窗⼝减半 将阈值设为当前拥塞窗⼝ 进⼊快恢复阶段（重发对端需要的包，⼀旦收到⼀个新的 ACK 答复就退出该阶段） 使⽤拥塞避免算法 快速恢复 TCP New Ren 改进后的快恢复 TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到⼀个新的 ACK 包，就会退出快恢复。 在 TCP New Reno 中，TCP 发送⽅先记下三个重复 ACK 的分段的最⼤序号。 假如我有⼀个分段数据是 1 ~ 10 这⼗个序号的报⽂，其中丢失了序号为 3 和 7 的报⽂，那么该分段的最⼤序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报⽂，接收⽅顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报⽂，接收⽅顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 状态机 HTTP 是⽆连接的，所以作为下层的 TCP 协议也是⽆连接的，虽然看似 TCP 将两端连接了起 来，但是其实只是两端共同维护了⼀个状态</li></ul><p>TCP 的状态机是很复杂的，并且与建⽴断开连接时的握⼿息息相关，接下来就来详细描述下两种握⼿。 在这之前需要了解⼀个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。 3次握手</p><p>在 TCP 协议中，主动发起请求的⼀端为客户端，被动连接的⼀端称为服务端。不管是客户端还是服务端，TCP 连接建⽴完后都能发送和接收数据，所以 TCP 也是⼀个全双⼯的协议。 起初，两端都为 CLOSED 状态。在通信开始前，双⽅都会创建 TCB。 服务器创建完 TCB 后遍进⼊ LISTEN 状态，此时开始等待客户端发送数据。</p><p>简化为：C 发请求连接， S 确认 也发起连接， C 确认 每次握手作用： 第一次：S 确认 自己可以接受 C 发送的报文段 第二次：C 确认 S 收到了自己发送的报文段，并且确认 自己可以接受 S 发送的报文段 第三次握手：S 可以确认 C 收到了自己发送的报文段</p><p>TCP报文中有个TCP标记</p><p>TCP建立连接过程 seq 发送方发送的序列号 ack 期望收到的序列号</p><p>ACK 是确认cs syn a客户初始序列号sc syn ack=a+1确认收到客户的SYN b服务器初始序列号cs ack=b+1进入连接状态服务端收到确认后，也进入连接状态 一个 TCP 连接，客户端和服务器共发 3 个包。作用是确认双方接收和发送能力正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质是连接服务器指定端口，建立 TCP 连接，同步连接双方序列号和确认号，交换 TCP 窗口大小信息。 客户端 Closed，服务端 Listen。</p><ul><li>一次：客户端给服务端发 SYN 连接请求报⽂段，指明客户端⾃身的数据通讯初始化序列号 ISN，客户端进⼊ SYN_SEND 状态。 首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。</li><li>二次：服务器收到客户端 SYN 后，如果同意连接 以自己的 SYN 作为应答，且指定自己数据通讯的初始化序列号 ISN。同时把客户端 ISN + 1 作为 ACK 的值，表示自己已收到客户端的 SYN，服务器 SYN_REVD状态。 确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y</li><li>三次：客户端收到 SYN 后，向服务端发送⼀个确认报⽂ ACK 报文，把服务器的 ISN + 1 作为 ACK 的值，表示已收到了服务端的 SYN 报文，此时客户端ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时连接建⽴成功。。 确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。 为什么要三次</li><li>为了确认双方接收和发送能力都正常，防⽌失效的连接请求报⽂段被服务端接收，从⽽产⽣错误。</li><li>两次场景： <ul><li>客户端发连接请求A，连接请求报文丢失未收到确认，这时TCP 会启动超时重传的机制再次发送⼀个连接请求 B，B后来收到确认，建立连接</li><li>数据传完后释放连接，客户端共发两个连接请求报文段</li><li>第一个丢失，第二个到达服务端，丢失的只是在某些网络结点长时间滞留，延误到连接释放以后的某个时间才到服务端，此时服务端误认客户又发新的连接请求，于是向客户发确认报文段，同意建立连接，不用三次握手，只要服务端发出确认，就建立新连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。 连接过程就是相互确认初始序号的过程，告诉对方什么样序号的报文段能被正确接收。 第三次作用是客户端对服务器端的初始序号的确认。如果只两次，服务器没法知道自己的序号是否被确认就开始发数据然后一直等客户端请求连接浪费。同时也为了防止失效的请求报文段被服务器接收，出现错误。 场景：客户端发送⼀个连接请求 A，因为⽹络原因超时，这时TCP 启动超时重传的机制再发送个连接请求 B。此时B请求顺利到达服务端，服务端应答完就建⽴请求。如果请求 A 在两端关闭后抵达服务端，那么服务端认为客户端⼜要建⽴ TCP 连接，从⽽应答该请求并进⼊ ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，会导致服务端⼀直等待，造成资源浪费。 PS：建⽴连接中，任意端掉线，TCP 都会重发 SYN 包，⼀般重试五次，建⽴连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者⼲脆在不能处理的情况下拒绝请求。 4次握手 c向s发协议版本号、随机数和可用的加密方法。s收到后，确认加密方法，向c发个随机数和自己的数字证书。c收到后，检查数字证书是否有效，有效则再生成一个随机数，并用证书中的公钥对随机数加密，然后发给服务端，且提供前面所有内容的 hash 值供服务器端检验。s接收后，用自己的私钥对数据解密，同时向c发前面所有内容的 hash 值供客户端检验。这时双方都有三个随机数，按之前约定的加密方法，用这三个随机数生成秘钥，以后双方通信前，就用这个秘钥对数据加密后再传输。 4次挥手 TCP 是全双⼯的，在断开连接时两端都需要发送 FIN 和 ACK。</li></ul></li></ul><p>FIN标志位表示连接释放请求c向s发FIN，c进入FIN_WAIT_1状态s收到FIN发ack ,s进入CLOSE_WAIT状态,c收到ack进入FIN_WAIT2s向c发FIN，s进入last-ack状态(数据发完)c收到s的FIN，发ack进入TIME-WAIT状态，2MSL后s没有重发，c进入closed状态,s收到ack进入closed状态</p><p>刚开始双方都 ESTABLISHED 状态，假如客户端先发起关闭请求。过程：</p><ul><li>第一次： 客户端 A 发连接释放请求 FIN 报文，报文中指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。</li><li>第二次：服务端收到连接释放请求 FIN 之后，告诉应⽤层要释放 TCP 链接，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。</li><li>第三次：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进⼊LAST-ACK 状态。 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 PS：通过延迟确认的技术（通常有时间限制，否则对⽅会误认为需要重传），可以将第⼆次和第三次握⼿合并，延迟 ACK 包的发送。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次：客户端A 收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。该状态会持续2MSL（最⼤段⽣存期，指报⽂段在⽹络中⽣存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进⼊ CLOSED 状态。当 B 收到确认应答后处于关闭连接，也便进⼊CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。 为什么 A 要进⼊ TIME-WAIT 状态，等待 2MSL 时间后才进⼊ CLOSED 状态？ 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进⼊ CLOSED 状态，如果确认应答因为⽹络问题⼀直没有到达，那么会造成 B 不能正常关闭。 为什么四次？ 服务收到客户的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。ACK 用来应答，SYN 用来同步的。但关闭连接时，服务端收到 FIN 报文时，可能不会立即关闭 SOCKET，只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四次挥手。 四步：</li><li>第一次：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li>第二次：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li>第三次：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li><li>第四次：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。 四次原因是 TCP 连接是全双工的，需要双方分别释放到对方的连接，单独一方连接释放，只代表不能再向对方发数据，连接处于的是半释放状态。 最后一次挥手，客户端会等一段时间再关闭，是为了防止发给服务器的确认报文段丢失或出错，导致服务器端不能正常关闭。 防范SYN Flood攻击思路 TCP慢的原因 （从三次握手、流量控制、拥塞控制回答） TCP粘包 默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能. 如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包. 下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据. 其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</li><li>多次发送之前间隔⼀个等待时间：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li><li>关闭Nagle算法：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li><li>进⾏封包**/拆包：**封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。 UDP不会粘包</li><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。 TCP 和 UDP UDP TCP 是否连接 无连接(发数据前不需要建立链接。) 面向连接 是否可靠 不可靠传输，收到什么数据就传递什么数据，并且也不会备份数据，对⽅能不能收到是不关⼼的 不使用流量控制和拥塞控制，⼀直会以恒定的速度发送数据。即使⽹络条件不好，也不会对发送速率进⾏调整。这样实现的弊端就是在⽹络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求⾼的场景（⽐如电话会议）就需要使⽤ UDP ⽽不是 TCP。 可靠传输（无差错，不丢失，不重复，且按序到达），使用流量控制和拥塞控制 连接对象个数 一对一，一对多，多对一和多对多，单播，多播，⼴播 一对一 传输方式 报文 字节流 首部开销 首部开销小，仅 8 字节，⾼效 首部最小 20 字节，最大 60 字节 场景 实时应用，视频会议、直播，QQ聊天、在线视频、网络语音电话 可靠传输的应用，文件传输，远程登录 套接字编程 node 端到端 网络层 找另一台计算机地址，判断是否同一个子网，传输数据，主机到主机通信 网络由多个子网组成，广播的数据在同一个子网的计算机才能收到。同一个子网的计算机传输数据通过广播，不在同一个子网的计算机传输数据会先发给网关，网关再进行转发。为了区分MAC地址是否为同一个子网，产生了IP协议。 路由器开始没有路由表，会先广播0.0.0.0，收到与她连接的IP进行记录 网络层之间数据传输，路由器连路由器或设备，路由器决定着数据传输路径 路由器里面有MAC映射表，网卡发数据包含源MAC和目标MAC，如果这两个MAC都在同一个路由器上也就是局域网 内网直接转发，如果不在就要通过网关发出去，网关再将数据转发到另一个路由器，路由器外网IP找IP，找到目标IP后再传数据 路由器主要作用网络层，决定数据在网络中传输的路径，相邻节点只有一个路由器可以通过MAC表映射也就是内网都连接同一个路由器，多个路由器之间跨节点传输？</li></ul><p>虚拟互联网络 实际互联网比较复杂，如果大家都遵循IP协议就可以屏蔽物理网络之间的差异，网络中的主机用IP协议连接时，无需关注细节，就像dom元素转为虚拟dom结构，方面跨平台开发。</p><p>IP协议</p><p>使复杂网络变为虚拟互联网络，网络层屏蔽细节差异专注数据转发，解决虚拟网络中数据报文传输路径的问题，迪杰特斯拉算法。 ip地址32位，会变、mac地址48位不会变</p><p>IP通常用点分十进制表示0-255</p><p>数据格式</p><p>下图每一行是32bit位，4字节，至少20位 IP协议版本：通信双方必须一致，主流IPV4,IPV6 首部位长度：4位，最大1111是15，32bit=4byte 4x15=60字节 总长度：16位，最大1111111111111111是65535，总长度若大于MTU 15000字节，会自动进行分片 标志：标志IP报文是否可以分片 片偏移：如果分片，当前数据帧保留的第几个分片数据 key TTL：IP数据报文网络寿命，每经过一个设备(路由器/计算机)，TTL减1，当为0时丢弃该报文。作用：当找不到终点时，避免无限传输消耗带宽。为TCP超时重传提高了基础 8位协议：TCP UDP</p><p>首部校验和：接收方校验头部是否出错</p><p>转发流程 (数据链路层+网络层) 先在网络层通过路由表找到目标IP，再通过数据链路层获取MAC地址发送数据。数据帧每一跳的MAC都在变，IP数据包每一跳的IP不变。 计算机-路由器逐跳进行</p><p>路由表：计算机或路由器都有，MAC也有</p><p>ARP协议 之前，数据链路层的路由不知道对方MAC地址会通过广播获取信息，现在是由网络层告知数据链路层对方的MAC。网络层如何知道目标地址的MAC？ARP协议/地址解析协议</p><p>通过查询缓存表 arp -a 没有缓存就广播</p><p>ARP协议内容封装在数据链路层的帧里面，但是属于网络层因为用到了IP地址</p><p>mac地址寻找判断是否同一子网(target IP与本机子网掩码与运算（获取网络地址）)，用APR协议通过广播获取target的mac地址获取目的MAC地(网关mac地址) RARP协议 逆地址解析协议</p><p>IP地址子网划分</p><p>IP地址分类 公司的前16位是网络号，后16位主机号，网络号一样说明在同一子网</p><p>1.2.3.4根据上图判断是A类地址，那么它的最大最小主机号不能分配给特定主机，最小主机号表示当前A类地址的网络段ping 192.168.0.1，最大主机号表示广播地址，如果向255.255.255发送数据，将会广播到当前网络段的所有主机</p><p>补充图：主机数量减去2，特殊主机号不能分配，子网数量也相应减去特殊网络号，最小网络号加1，最大最小主机号要相应减去。最大主机号254说明可以有254个主机</p><p>判断IP地址？ 125.125.3.60将首8位也就是125转为二进制01111101，0开头是A类 回环地址 127.0.0.1用来ping 不属于任何一类地址，只要本地启动，这个地址永远都是通的</p><p>划分子网 100人申请C类，256人申请B类但是多余地址空间会浪费，所以出现子网划分。添加子网号 193.10.10.0是C类地址，24位主机号，8位网络号 第25位看作子网号，0或1，范围是0-127，128-255 第26位到32位，后7位是网络号</p><p>节省IP地址原理？ 100人申请C类，表示254个主机，原来主机号要分配到254，多余154个IP 现在主机号只用分配到126，只浪费26个IP 子网掩码 作用：判断IP的网络号，划分子网后网络段数据变多</p><p>网络号有多少位，就有多少连续的1，主机号是0，再转为10进制</p><p>通过子网掩码快速得到IP地址网络号？193.10.10.6 C类子网掩码255.255.255.128 IP地址和子网掩码转二进制与运算后换为点分10进制就是IP对应的网络号 无分类编址CIDR(推荐) 不像网络号位数受限制，更灵活</p><p>斜杠后面的数字表示网络号有多少位</p><p>100人分配/25, 网络前缀为25位的IP号 假设100人分为2个部门，公司分配24位，子部门是25位数</p><p>网络地址转换NAT技术 路由上一级加了网关，对外是网关IP，对内是局域网IP 为什么：因为IPV4最多有40亿的地址，而IP地址规划不合理导致浪费造成不够用的情况。所以有了NAT网络地址转换技术 是什么：将IP分为内网IP和外网IP，内网和网络通信通过路由器转换成外网IP，减少IP使用量，增加通信复杂度 网络拓扑结构包含边缘部分及核心部分，边缘部分，比如：家庭/公司有很多终端设备，包括手机、电脑、它们统一连到路由器也就是wifi、路由器连到网关，网关连到地区ISP。一个家庭只有一个路由器连接一个网关，每个终端都有唯一ip地址。 举例：LAN局域网是个屋子，这个屋子只有一个门 ，门就是网关。屋子里的人各有个的名字，但是他们想要走出去，却只有通过一个相同的门。光纤到家是ip地址给路由器了，然后路由器分给每个设备一个地址，每个设备通过路由器转换后在传递信息。一个WIFI下属于一个LAN局域网，接入这个LAN局域网的设备会获取一个IP地址，这个IP地址不可能所有的设备都是一样的，但一定是在一个网段中也就是内网。例如设备获取的ip地址可能是192.168.1.X，X=1-254 。一个局域网只有一个网关。 不管是家庭还是企业，内部都有很多终端设备，比如：手机 平板 电脑，外网通信时候并不会直接访问到具体设备的IP，而是与区域内统一的网关连接，然后网关再转发到具体设备进行通信。 这些边缘的叶子节点都要通过一个根节点网关，连接到ISP 局域网网关使用外网IP，内部使用内网地址，解决不同设备连接互联网的问题以及IP地址不够用的问题</p><p>IP地址分为内网地址和外网地址，内网只能与同一个网关下的IP通信，外网可以全球通信。内网地址需要避免与外网重复，外网是全球唯一公网IP。 内网地址分类：</p><p>不同局域网可以使用相同的IP地址，不会冲突 内网所有设备同时使用一个外网IP请求外网服务，外部怎么知道是哪个具体设备在请求？所以有了NAT技术</p><p>是什么：用于多个主机通过一个公网IP访问互联网的私有网络，将内网的IP地址转化为外网IP地址进行通信，减缓了IP地址消耗，也增加了网络通信复杂度 过程：设备某个进程 收发数据时IP和端口都会经过路由器映射转换，映射的过程就是网络地址转换原理，映射表成为NAT表</p><p>ICMP协议 网际控制报文协议Internet Control Message Protocol 比如ping：验证主机到主机之间是否正确的报文，不涉及端口，封装在IP报文里面，IP报文首部里面有上层的协议类型：TCP UDP ICIP A访问B，B返回了ICMP差错报文报告告知A当前IP出错 是什么：辅助IP协议进行数据传输，可以报告传输中的错误信息或异常，http3.0使用UDP, 数据的可靠性通过ICMP控制。ICMP协议是封装在了IP数据报文里的8位协议中，只是IP数据报文里的一组数据</p><p>ICMP报文格式：32位首部+报文数据</p><p>ICMP协议是封装在了IP数据报文里的8位协议中，当IP数据报中的8位协议为1时，说明IP数据是ICMP报文数据</p><p>ICMP协议报文分两大类：差错、询问 差错报告报文：端到端之间的错误，断网/重定向 我理解：这里类型值是3，反应到TCP再到HTTP就是响应报文的状态码</p><p>询问报文：主要是验证网络是否畅通 对时间进行同步的时候会发询问报文</p><p>应用 Ping ip：主要使用ICMP询问报文，使用ping命令时受限会组装一个IP数据报文里面再组装一个包含ICMP的询问报文通过IP协议发送，通过数据链路层(网卡) 发送出去，网卡再到网络层的路由，路由查找目标IP。 如图：32字节代表IP报文长度，而IP报文首部至少20字节，说明ICMP报文长度为12字节，时间代表该网络从请求到应答的时间(应用ICMP询问报文)，TTL代表该数据在网络传输后还剩余的寿命，如果TTL=0会丢弃当前报文</p><p>网络故障排查 ping 127.0.0.1 本机回环地址，判断是否本机协议栈有问题，重装系统 ping 网关/路由器地址，内网一般是192.168.0.1，验证网线或wifi是否有问题 ping 远程地址 Traceroute应用 探测IP数据报在网络中走过的路径，经过的IP地址。原理是利用ICMP差错报文和TTL 回顾：每经过一个网络设备IP，TTL减1，为0时丢弃该报文，且该设备会发出ICMP终点不可达差错报文返回给客户端(包含出错的IP)，源主机会收集到出错IP</p><p>过程：</p><ol><li>首先，源主机A封装一个TTL为1的报文，到达中型网络时TTL为0，向源主机A返回ICMP差错报文且包含自己的IP，源主机A记录该IP</li><li>然后Traceroute，源主机A Traceroute 再封装一个TTL为2的报文，数据就传到了大型网络，此时TTL为0，大型网络会丢弃当前报文，往源主机A发送一个ICMP差错不可达报文，源主机A记录大型网络的IP，依次向前</li><li>最终到B主机，B主机会发出回应报文，表示已收到数据</li></ol><p>tracert github.com 首先会显示github.com的IP，然后显示每一跳的IP，路由 网关 运营商</p><p>Traceroute协议 tracert 192.168.0.2 会返回，到目标IP中间经过的IP地址，利用ICMP协议差错报告拿到报错的IP进行记录， 路由概述 解决：路由表下一跳怎么选才是最优路径，让数据传的更快 网络拓扑结构通过数据结构图描述，每个小的网络集群都是一个自治系统AS</p><p>自治系统 处于一个管理机构下面的网络设备群，比如公司 学校各自是自治系统 AS内网之间自行管理，AS对外提供一个或多个出入口，理解为网关，内网之间通过路由器转发，想和其他AS系统通信，给路由设外网IP也就是网关。 理解为，内网也就是局域网，一个父节点下的子节点内部通信，而局域网和局域网通信，也就是父节点和父节点之间各自通信。下图中每个ISP都可以看作一个AS系统</p><p>AS系统内部路由协议：内部网关协议，RIP OSPF AS系统外部路由协议：外部网关协议，BGP</p><p>RIP 协议 DV算法运行在图里面，每个节点两个向量Di Si， Di：当前节点到别的节点的距离（初始的距离不是很准）</p><p>当前节点A会与它相邻节点B C D F交换节点信息，下图就是A收到的信息，A接收相邻节点信息的同时也就是实际通信之后知道相邻节点真实的距离</p><p>每一列代表各个节点到其他节点的距离，可能A-B和B-A距离不同，因为它们走的路径不同</p><p>Si：当前节点A到别的节点的下一个节点是什么，初始化为空 A和B交换路由信息，计算A经过B到下一个节点的距离</p><p>以太网协议</p></div></div></main><footer class="VPDocFooter" data-v-01c1258a data-v-232666cb><!--[--><!--]--><div class="edit-info" data-v-232666cb><!----><div class="last-updated" data-v-232666cb><p class="VPLastUpdated" data-v-232666cb data-v-ebee81f6>Last updated: <time datetime="2024-06-12T09:26:54.000Z" data-v-ebee81f6></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-1125a642 data-v-7ce9edcf><div class="container" data-v-7ce9edcf><!----><p class="copyright" data-v-7ce9edcf>2024.06.06 @JAMI</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"language_js_reflect.md\":\"D4elTM4B\",\"language_java.md\":\"UtYYqWO2\",\"database_mysql.md\":\"Bj7W39Br\",\"common_markdown.md\":\"DL_qROo1\",\"common_cli.md\":\"DllzkTp2\",\"index.md\":\"Cr9kT78i\",\"language_js_regexp.md\":\"BRcvAhTA\",\"language_js_es6.md\":\"D5XVG1ZQ\",\"language_js_array.md\":\"GKEn11ha\",\"common_nginx.md\":\"Dn7T8cYb\",\"datavisual_threejs.md\":\"KNQuEsk6\",\"engineering_webpack.md\":\"COyeGz6h\",\"language_js_moudles.md\":\"CbJUZ3D6\",\"pc_index.md\":\"Dp4l-A0I\",\"common_nvm.md\":\"Bsd4EEsu\",\"database_index.md\":\"DLOF4tF4\",\"language_js_function.md\":\"LkjD7z1l\",\"language_css.md\":\"BCIDXgrN\",\"common_product.md\":\"D3nuqNX_\",\"engineering_pkgtool.md\":\"BUhlfQaD\",\"datavisual_webgl.md\":\"07vqMh-U\",\"engineering_npx.md\":\"BO3kbXik\",\"language_js_async.md\":\"CcjOONJP\",\"engineering_rollup.md\":\"NnPVyN1M\",\"common_ui.md\":\"BppcMzKd\",\"mobile_index.md\":\"D7r3vpJD\",\"engineering_npm.md\":\"CmQL7zG1\",\"computed_datastructure.md\":\"2FexojfD\",\"database_mongoose.md\":\"CLGyzZ0Z\",\"common_blog.md\":\"CqKKs6Fl\",\"node_index.md\":\"DiS5vjPv\",\"language_js_generator.md\":\"CRKe83dA\",\"computed_designpattern.md\":\"Xnl-UL-W\",\"language_index.md\":\"DM5Jd1zS\",\"engineering_index.md\":\"3S3dJ7Rf\",\"computed_compiler.md\":\"vVnl7cHT\",\"datavisual_opengl.md\":\"kGuQ8k6E\",\"common_学习路径.md\":\"zut865UA\",\"engineering_buildtool.md\":\"C54eaY7X\",\"language_js_processcontrol.md\":\"CvEss_gV\",\"pc_eventloop.md\":\"DQqXz8db\",\"engineering_vite.md\":\"COqrDDKo\",\"language_js_object.md\":\"BVQKDmpe\",\"language_ts.md\":\"TsC4kuOp\",\"computed_os.md\":\"hqJR0sBu\",\"pc_react_index.md\":\"Cj2OlPYZ\",\"language_js_promise.md\":\"RVHwwKB1\",\"language_js_math.md\":\"DXO89uqU\",\"common_no.md\":\"DoBaIujB\",\"engineering_cnpm.md\":\"DvVPBL0k\",\"language_js_datatype.md\":\"C943d9qi\",\"language_js_index.md\":\"BM54qnSd\",\"pc_vue_pina.md\":\"DLpFW_QE\",\"language_js_set map.md\":\"9BpMv1ZE\",\"language_go.md\":\"Ddthcb_t\",\"common_api-examples.md\":\"B9rDVicC\",\"pc_vue_vue3.md\":\"C0OaGfPR\",\"datavisual_index.md\":\"BCfIrq7Y\",\"pc_vue_vuex.md\":\"BQ-lOfD0\",\"language_python.md\":\"BJLBpcW4\",\"language_js_date.md\":\"wQvcqUab\",\"datavisual_animation.md\":\"Bq8oPfd0\",\"webgis_cesicum.md\":\"BUcF4m6U\",\"language_js_string.md\":\"9w7Nja7U\",\"engineering_pnpm.md\":\"DCE1Qzl7\",\"language_js_proxy.md\":\"Bg2qJJxT\",\"datavisual_echarts.md\":\"C6r1nu2m\",\"webgis_index.md\":\"BZGbAr9w\",\"engineering_yarn.md\":\"BZHH9Nmp\",\"language_js_json.md\":\"0rPgLDET\",\"engineering_performance.md\":\"YVV5ZzPa\",\"database_redis.md\":\"aPcCtF58\",\"webgis_arcmap.md\":\"BsIJaUOP\",\"guide_aaa.md\":\"BktvlX01\",\"datavisual_canvas.md\":\"DlLmj2zQ\",\"computed_organization.md\":\"09Va0_y4\",\"webgis_geoserver.md\":\"DH2bqSuo\",\"pc_vue_vue3-source.md\":\"D3Era47R\",\"pc_vue_index.md\":\"BkCrOoc1\",\"pc_gc.md\":\"C8zqnzJ5\",\"resume_index.md\":\"mNng4F9F\",\"database_mongodb.md\":\"CUiugpcJ\",\"language_js_operator.md\":\"njQslLoG\",\"tool_index.md\":\"ClleSYpk\",\"pc_vue_vue-router.md\":\"vF4YcDTq\",\"computed_network.md\":\"gSfoJl5P\",\"records_index.md\":\"B45ERtfd\",\"language_html.md\":\"DLDi-MY3\",\"computed_infosecurity.md\":\"CP6S91LZ\",\"pc_browser.md\":\"CrvwsBU7\",\"webgis_openlayer.md\":\"DSEixzNh\",\"pc_vue_vue2.md\":\"DksfUeLx\",\"pc_vue_vue2-source.md\":\"PX1Cuu_a\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Jami's blog\",\"description\":\"自我介绍\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"logo.svg\",\"outlineTitle\":\"页面导航\",\"outline\":[2,6],\"nav\":[{\"text\":\"官网合集\",\"link\":\"/tool/index\"},{\"text\":\"计算机基础\",\"items\":[{\"text\":\"数据结构\",\"link\":\"/computed/dataStructure\"},{\"text\":\"计算机网络\",\"link\":\"/computed/network\"},{\"text\":\"计算机组成原理\",\"link\":\"/computed/organization\"},{\"text\":\"操作系统\",\"link\":\"/computed/os\"},{\"text\":\"编译原理\",\"link\":\"/computed/compiler\"},{\"text\":\"设计模式\",\"link\":\"/computed/designPattern\"}]},{\"text\":\"语言\",\"items\":[{\"text\":\"概述\",\"link\":\"/language/index\"},{\"text\":\"HTML\",\"link\":\"/language/html\"},{\"text\":\"CSS\",\"link\":\"/language/css\"},{\"text\":\"JS\",\"link\":\"/language/js/index\"},{\"text\":\"TS\",\"link\":\"/language/ts\"}]},{\"text\":\"客户端\",\"items\":[{\"text\":\"PC\",\"link\":\"/pc/index\"},{\"text\":\"移动端\",\"link\":\"/mobile/index\"},{\"text\":\"数据可视化\",\"link\":\"/dataVisual/index\"},{\"text\":\"WEBGIS\",\"link\":\"/webgis/index\"}]},{\"text\":\"工程化\",\"items\":[{\"text\":\"脚手架(cli)\",\"link\":\"/common/cli\"},{\"text\":\"Git\",\"link\":\"/node/index\"},{\"text\":\"打包工具\",\"link\":\"/engineering/buildTool\"},{\"text\":\"包管理工具\",\"link\":\"/engineering/pkgTool\"},{\"text\":\"性能 监控 埋点\",\"link\":\"/engineering/performance\"},{\"text\":\"node nvm npm安装\",\"link\":\"/common/nvm\"},{\"text\":\"CSS工程化\",\"link\":\"/common/nvm\"},{\"text\":\"axios fetch mock\",\"link\":\"/common/nvm\"}]},{\"text\":\"日常记录\",\"items\":[{\"text\":\"功能问题合集\",\"link\":\"/records/index\"},{\"text\":\"组件库\",\"link\":\"/common/nvm\"},{\"text\":\"低代码\",\"link\":\"/common/nvm\"}]},{\"text\":\"我的简历\",\"link\":\"/resume/index\"}],\"sidebar\":{\"/engineering/buildTool\":[{\"text\":\"webpack\",\"link\":\"/engineering/webpack\"},{\"text\":\"vite\",\"link\":\"/engineering/vite\"}],\"/engineering/pkgTool\":[{\"text\":\"npm\",\"link\":\"/engineering/npm\"},{\"text\":\"yarn\",\"link\":\"/engineering/yarn\"},{\"text\":\"cnpm\",\"link\":\"/engineering/cnpm\"},{\"text\":\"pnpm\",\"link\":\"/engineering/pnpm\"}],\"/webgis/index\":[{\"text\":\"cesicum\",\"link\":\"/webgis/cesicum\"},{\"text\":\"openlayer\",\"link\":\"/webgis/openlayer\"},{\"text\":\"arcmap\",\"link\":\"/webgis/arcmap\"},{\"text\":\"geoserver\",\"link\":\"/webgis/geoserver\"}],\"/database/index\":[{\"text\":\"mysql\",\"link\":\"/database/mysql\"},{\"text\":\"mongoose\",\"link\":\"/database/mongoose\"},{\"text\":\"redis\",\"link\":\"/database/redis\"},{\"text\":\"mongodb\",\"link\":\"/database/mongodb\"}],\"/pc/index\":[{\"text\":\"浏览器\",\"link\":\"/pc/browser\"},{\"text\":\"vue\",\"link\":\"/pc/vue/index\"},{\"text\":\"react\",\"link\":\"/pc/react/index\"}],\"/pc/vue\":[{\"text\":\"vue\",\"items\":[{\"text\":\"vue\",\"link\":\"/pc/vue/index\"},{\"text\":\"vue2\",\"link\":\"/pc/vue/vue2\"},{\"text\":\"vue3\",\"link\":\"/pc/vue/vue3\"},{\"text\":\"vuex\",\"link\":\"/pc/vue/vuex\"},{\"text\":\"pina\",\"link\":\"/pc/vue/pina\"},{\"text\":\"vue-router\",\"link\":\"/pc/vue/vue-router\"},{\"text\":\"vue2-source\",\"link\":\"/pc/vue/vue2-source\"},{\"text\":\"vue3-source\",\"link\":\"/pc/vue/vue3-source\"}]}],\"/dataVisual/index\":[{\"text\":\"canvas\",\"link\":\"/dataVisual/canvas\"},{\"text\":\"opengl\",\"link\":\"/dataVisual/opengl\"},{\"text\":\"threejs\",\"link\":\"/dataVisual/threejs\"},{\"text\":\"webgl\",\"link\":\"/dataVisual/webgl\"},{\"text\":\"动画\",\"link\":\"/dataVisual/animation\"},{\"text\":\"Echarts\",\"link\":\"/dataVisual/echarts\"}],\"/language/js/index\":[{\"text\":\"运算符\",\"link\":\"/language/js/operator\"},{\"text\":\"流程控制\",\"link\":\"/language/js/processControl\"},{\"text\":\"数据类型\",\"link\":\"/language/js/dataType\"},{\"text\":\"String\",\"link\":\"/language/js/string\"},{\"text\":\"Array\",\"link\":\"/language/js/array\"},{\"text\":\"Function\",\"link\":\"/language/js/function\"},{\"text\":\"Object\",\"link\":\"/language/js/object\"},{\"text\":\"Reflect\",\"link\":\"/language/js/reflect\"},{\"text\":\"Proxy\",\"link\":\"/language/js/proxy\"},{\"text\":\"JSON\",\"link\":\"/language/js/json\"},{\"text\":\"RegExp\",\"link\":\"/language/js/regExp\"},{\"text\":\"Math\",\"link\":\"/language/js/math\"},{\"text\":\"Date\",\"link\":\"/language/js/date\"},{\"text\":\"Promise\",\"link\":\"/language/js/promise\"},{\"text\":\"Generator\",\"link\":\"/language/js/generator\"},{\"text\":\"async/await\",\"link\":\"/language/js/async\"},{\"text\":\"模块化moudles\",\"link\":\"/language/js/moudles\"},{\"text\":\"ES6\",\"link\":\"/language/js/es6\"}]},\"footer\":{\"copyright\":\"2024.06.06 @JAMI\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>