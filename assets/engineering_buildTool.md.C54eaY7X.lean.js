import{_ as r,o,c as d,j as e,a as t,t as i,a5 as p}from"./chunks/framework.DnJ-_PtE.js";const S=JSON.parse('{"title":"构建工具","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/buildTool.md","filePath":"engineering/buildTool.md","lastUpdated":1718254561000}'),s={name:"engineering/buildTool.md"},n=p("",12),c=e("code",null,"children[{}]",-1),l=e("p",null,[t("或者toRefs(state)把每一项都变成ref对象。导出"),e("code",null,"...toRefs(state)"),t(" 计算属性computed 创建一个新响应式数据，依赖于其他属性 computed的value是只读的 想改：做set监听 watchEffect 依赖谁改变才会变 区别 计算属性依赖的值，计算新值 watch监听现有的值 第一次不输出，值改变后才会输出 "),e("code",null,"watch(值，(){})")],-1);function u(a,h,v,f,m,b){return o(),d("div",null,[n,e("p",null,[t("get:依赖收集。组件1data有一个a属性，a属性更改后要把所有页面更新一次。a只在一个组件用，没必要更新所有组件，改进：哪里使用a就更新哪里。怎么知道哪里用a 初始化vue对象，会触发get收集依赖，dep.depend() set更新视图，调用dep.notify方法，把收集的依赖做更新 3不用defineProperty() ，用proxy，不支持ie8 defineProperty() 针对对象每一个属性，有多少就调用多少次，每一个调用会降低性能 proxy是new一个对象，得到代理对象，操作代理对象，触发getset，不改变原对象。提升初始化响应式性能。 根本区别：一个在原对象改，一个在代理对象上操作，proxy解决了数组响应式，新增动态添加响应式问题，2里面调用push方法才能触发响应式，不能监听动态变化，因为defineProperty() 针对对象，数组不是对象。proxy可以直接修改数组下标触发响应。 diff算法:比对新老的虚拟dom virtual dom 比对前已经生成新的虚拟dom,再比对。虚拟dom并不是真实dom，可以看作一个对象，第一层是他的父级元素。 4个要素：节点类型type,文字节点text，属性attribute，子节点"),c,t(" 树状结构AST语法树的衍生，最外层就是根 diff算法为什么要比对新老的虚拟dom？更新DOM时怎么更新成本最小？只改文字还是删除重新渲染？ 如果是type变，直接删了重新创建；如果是文字，直接修改；如果节点下有个key值，删了重新创建，所以要保证key值稳定，key不能用index 2比对会一个一个比对，每个dom都要比一次。但是比如h1标签本身不会改变，因为它上面没有绑定任何vue指令。他会把不可能变的都要比一次。 3比对次数更少，比对之前会筛选出动态节点标记为1，静态节点标记0，只比对标记为1的 3把静态的标签放在了render外面，初始化就创建，不会把不变的再创建，把它缓存下来，高效利用缓存 为什么块6倍数？proxy diff render react diff算法：整个比对过程做时间切片，并行或者串行 v3实战 vite 类似webpack,是构建工具，用来打包 vite1.0只支持vue3 webpack核心：打包，其他功能通过插件实现 打包：开发必须要模块化import，浏览器又不认识import，所以要通过webpack从入口文件分析成引用树，放在一个文件中，把import代码转换成可以执行的代码 开发必须要模块化import，浏览器又不认识import，vite不用打包，使用esm可以直接跑， esm写script标签，加type=moudle，不用编译 import 好处：节约打包时间 esm只有现代浏览器支持，不兼容 可以用vite开发，上线时用webpack打包 vue3新特性 vite+vue3初始化 新写法 没有node moudle和router,安装依赖，加路由 3里面怎么加路由,注意版本 vue-router@next vuex@next 3的编码是函数式编程，路由也要函数式编程 旧：import vue router new rules 新：调用方法创建，createRouter({routes:[]}) 更支持history export 对象 写法 完全支持vue2,向下兼容 vue3生命周期没有create beforecreate被setup代替 一个变量ref 对象reactive() setup里面没有this,它的this指向undefined ref要.value 复杂的用reactive() 组合一系列方法的调用，从vue调入一些方法，直接使用。。。之前2都是写在对象上 3父子传值 props参数 setup（props） 3子父传值 setup(props,contex) contex.emit contex相当于this 3provide方法 定义变量 provide('a','111) 子组件中直接用inject('a') 跨组件传值 2写法弱点：当组件复杂度增加，维护难度也会增加，同一个功能是散布的。逻辑不能直接拿出去作为独立的JS代码，还保留this指向。 3相当于react里的class hook，，加强了ts的支持 vue3+ts react+ts+hook 性能提高 重写DOM，diff算法 只更新更改的DOM 2中全部对比，3中静态节点初始化之后只比较动态绑定的 nuxt.js webpack打包体积 所有方法只使用了部分，只打包需要的 允许有多个根节点，使得层次更浅 更好的TS支持，本质采用后台思想，例如java composition 把组件写的东西渲染到画布上而不是渲染到dom Proxy 响应式数据代替原有的defineprop，监听劫持proxy es6，改写了数组的7个方法 语法： 整体推荐函数式编程，更强大的功能：传送文：制定某些东西放入某地方，更好的渲染canvas 很少有new... 大部分从vue vue-router解构出对应的函数 聚合式API 以前放入Option API中，现在用setup,聚合API setup拿到props属性,context setup还没有创建好组件实例，所以不能用this setup中return啥，事物中直接用 响应式数据怎么做？ definePro ref创建响应式对象 从vue解构出ref ref(0)括号里写初始值，几个状态写几次 通过ref创建出来的状态是一个对象，对其中的value做了get和set监听 js中用.value获取值 视图中："),e("code",null,i(a.state),1),t(" 后续修改状态时 reactive 从vue解构出reactive 比如执行一个方法创建多个状态 get set has ownkeys代理 reactive返回代理对象")]),l])}const _=r(s,[["render",u]]);export{S as __pageData,_ as default};
