import{_ as s,o as a,c as i,a5 as n}from"./chunks/framework.DnJ-_PtE.js";const b=JSON.parse('{"title":"垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"pc/gc.md","filePath":"pc/gc.md","lastUpdated":1718184414000}'),l={name:"pc/gc.md"},e=n(`<h1 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h1><blockquote><p>浏览器多进程架构中，渲染进程中包含JS V8引擎线程，垃圾回收机制是JS引擎的功能，当然也可以说是浏览器的垃圾回收机制</p></blockquote><p>前置知识：<a href="/computed/os/##进程与线程">进程与线程</a> <a href="/computed/os/##堆与栈">堆与栈</a></p><h2 id="什么是垃圾回收" tabindex="-1">什么是垃圾回收 <a class="header-anchor" href="#什么是垃圾回收" aria-label="Permalink to &quot;什么是垃圾回收&quot;">​</a></h2><p>垃圾回收：JS代码运行时要分配内存空间来储存变量和值。当变量不参与运行时，系统收回被占用的内存空间</p><p>回收机制：定期对不用的变量、对象所占的内存释放，原理是找到不再用的变量，释放其占的内存。存在两种变量：局部和全局。全局生命周期持续到页面卸载；局部声明在函数中，生命周期从函数执行开始到执行结束，过程中，局部变量在堆或栈中存它们的值，函数执行结束后，这些局部变量不再被用，所占空间会被释放。不过，当局部变量被外部函数使用时(闭包)，函数执行结束后，函数外部变量依然指向函数内部局部变量，此时局部变量不会回收。 回收方式：标记清除，引用计数。</p><p>标记清除隔一段时间遍历清除，引用计数是立即清除，需要计数器且不知道上限且有循环引用问题。</p><h2 id="为什么需要垃圾回收机制" tabindex="-1">为什么需要垃圾回收机制 <a class="header-anchor" href="#为什么需要垃圾回收机制" aria-label="Permalink to &quot;为什么需要垃圾回收机制&quot;">​</a></h2><p>从栈和堆的角度看：</p><p>对于栈来说，一个函数执行完，栈上分配的局部变量等会随着函数调用栈的弹出而自动释放，通常不需要专门回收。 对于堆来说，堆上分配的内存空间主要用于存储对象。当程序中创建大量对象，并且某些对象不再被使用后，如果没有垃圾回收机制，这些对象所占用的内存空间就会一直被无效占用，导致堆空间大量浪费，可能耗尽内存。</p><p>通过垃圾回收机制，可以定期地扫描堆，识别出不再被引用的对象，将它们所占的内存回收，释放出来供其他新对象使用，确保堆空间合理利用，避免因内存不足引发程序崩溃。</p><p>例如，在长时间运行的复杂程序中，可能会创建很多临时对象，这些对象使用后可能很快就不再需要了，垃圾回收机制能及时清理它们，保证堆内存始终有足够的可用空间满足程序后续的运行需求。</p><p>总结一下：</p><ol><li>释放内存资源：能自动识别并清理不再被使用的对象所占的内存空间，使这些内存可以被重新利用，防止内存浪费</li><li>避免内存泄漏：帮助程序员避免因疏忽或错误导致未释放的内存持续积累，降低因内存泄漏引发程序崩溃的风险。</li><li>优化内存分配效率：通过合理地回收和再分配内存，让内存的使用更加高效和合理，提高程序的整体性能。</li><li>简化编程模型：开发者无需过多地操心内存释细节，更专注业务逻辑实现，提高开发效率。</li><li>维持系统运行稳定性：确保系统长时间运行过程中，不会因为内存问题出现异常，保障系统的可靠运行。</li></ol><h2 id="垃圾回收机制方法" tabindex="-1">垃圾回收机制方法 <a class="header-anchor" href="#垃圾回收机制方法" aria-label="Permalink to &quot;垃圾回收机制方法&quot;">​</a></h2><h3 id="标记清除-常见" tabindex="-1">标记清除(常见) <a class="header-anchor" href="#标记清除-常见" aria-label="Permalink to &quot;标记清除(常见)&quot;">​</a></h3><ol><li>原理 变量进入环境时，就标记这个变量为进入环境，永远不能释放带有进入环境标记的变量，当离开环境时，就标记为离开环境</li><li>过程 变量进入执行环境时，标记“进入环境”，被标记为“进入环境”的变量不能回收。 变量离开环境，标记为“离开环境”，标记“离开环境”的变量被内存释放。 垃圾收集器运行时给内存中的所有变量都加上标记。然后去掉环境中的变量(全局变量)以及被环境中的变量引用的标记(局部变量被引用)。之后再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁带标记的值并回收他们所占的内存空间。机制运行时候找被某块内存直接引用和间接引用的对象，打上标记，没有标记的清除。清理后内存碎片化，下一次分配空间需要遍历所有的判断size大于等于值再分配。v8优化添加标记整理，空内存整理到一边，清理边界内存。</li></ol><h3 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h3><ol><li>原理 每个值设引用的次数,跟踪记录每个值被引用次数</li><li>过程 当声明一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为 1,；相反，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没办法再访问这个值，就把所占内存给回收进来，垃圾收集器再次运行时，会释放引用次数为 0 的值。但是会有循环引用的问题，需要最终手动设为null。</li><li>缺点：循环引用问题</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> problem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();objA.someOtherObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objB;objB.anotherObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objA;}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。需要手动释放内存，设为null</p><p>特别是在 DOM 对象中，也容易存在这种问题：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.getElementById（’‘）；var myObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();myObj.element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element;element.someObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myObj;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样就不会有垃圾回收的过程。</p><h2 id="v8优化" tabindex="-1">V8优化 <a class="header-anchor" href="#v8优化" aria-label="Permalink to &quot;V8优化&quot;">​</a></h2><p>新生代：分为使用区、空闲区。使用区快满时，标记活动对象，复制到空闲区并排序，清理非活动对象，调换两个区域。当某对象复制到空闲区占用超过25%或多次复制后存活的对象放入老生区 老生代：原有的标记清除+标记整理算法+全停顿标记改为增量标记 为什么： 字符串、对象和数组没有固定大小，当他们大小已知时，才能对他们动态存储分配。JS 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当确定一个对象无用时，可以把它所占用的内存释放掉。如： var a=&quot;hello world&quot;; var b=&quot;world&quot;; var a=b;//这时，释放掉&quot;hello world&quot;，以便再引用 实现准确式 GC，算法采用分代式垃圾回收机制。V8 将内存（堆）分为新生代和老生代两部分。 新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 在讲算法前，先来说下什么情况下对象会出现在老生代空间中： • 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 • To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 老生代中的空间很复杂，有如下几个空间</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AllocationSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // TODO(v8:7464): Actually map this space&#39;s memory as read-only.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不变的对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新生代用于 GC 复制算法的空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OLD_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代常驻对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CODE_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代代码对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MAP_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代 map 对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代大空间对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新生代大空间对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    FIRST_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LAST_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FIRST_GROWABLE_PAGED_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OLD_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LAST_GROWABLE_PAGED_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MAP_SPACE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在老生代中，以下情况会先启动标记清除算法： • 某一个空间没有分块的时候 • 空间中被对象超过一定限制 • 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h2 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h2><p>意外的全局变量：用未声明的变量，意外创建全局变量，一直留在内存无法回收。遗忘的计时器或回调：setInterval 忘取消，如果循环函数有对外部变量的引用的话，那这个变量会被一直留在内存，无法被回收。脱离 DOM 引用：获取 DOM 引用，后面这个元素被删除，由于一直保留对这个元素的引用，所以无法回收。闭包：不合理的闭包导致某些变量一直被留在内存当中。意外的全局变量没有手动置空、未清理的计时器、回调函数、不恰当的闭包、console.log()、遗忘的事件监听、map set对象强引用建议用WeakMap、未清理的dom元素引用 所以，基本类型具有不可变性，变量重新赋值是在栈中开辟新内存空间存值，即将变量指向新内存空间，原来的还在会被垃圾回收机制回收。两者互不影响。引用类型复制是栈中开辟新内存空间存新地址，新旧地址指向堆中同一个实体，互相影响，也叫浅拷贝，只拷贝地址没有拷贝地址对应的对象。函数传参时候基本类型传值，引用类型传地址。而深拷贝会开辟新空间，并拷贝源地址对应的对象，新旧指针指向不同的实体数据，互不影响。</p><h2 id="避免内存泄漏" tabindex="-1">避免内存泄漏 <a class="header-anchor" href="#避免内存泄漏" aria-label="Permalink to &quot;避免内存泄漏&quot;">​</a></h2><p>减少垃圾回收 数组优化：清空数组，赋[]会创建新的空对象。将数组长度设 0。object优化：对象复用，不再用的对象设为 null。函数优化：循环中的函数表达式，可复用放函数外面。</p><h2 id="_1111" tabindex="-1">1111 <a class="header-anchor" href="#_1111" aria-label="Permalink to &quot;1111&quot;">​</a></h2><p>必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如： 64 var a=&quot;hello world&quot;; var b=&quot;world&quot;; var a=b;//这时，会释放掉&quot;hello world&quot;，释放内存以便再引用 垃圾回收的方法：标记清除、计数引用。 标记清除 这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。 引用计数法 另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为 1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。 用引用计数法会存在内存泄露，下面来看原因：function problem() { var objA = new Object();var objB = new Object();objA.someOtherObject = objB;objB.anotherObject = objA;} 在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。 特别是在 DOM 对象中，也容易存在这种问题： var element=document.getElementById（’‘）；var myObj=new Object();myObj.element=element;element.someObject=myObj;这样就不会有垃圾回收的过程。</p><h2 id="_2" tabindex="-1">2 <a class="header-anchor" href="#_2" aria-label="Permalink to &quot;2&quot;">​</a></h2><p>作用：解析Js脚本运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后处理, 单线程注意：GUI渲染线程与JS引擎线程的互斥关系，JS执行过长会阻塞页面渲染 某变量指向其他内存地址，原来内存地址中的数据就变成垃圾，自带的垃圾回收机制会回收，回收不了的就造成内存泄漏。垃圾回收机制有两种，标记清除、引用计数。常用的是标记清除。 垃圾回收：JS代码运行时要分配内存空间来储存变量和值。当变量不参与运行时，系统收回被占用的内存空间 回收机制：定期对不用的变量、对象所占的内存释放，原理是找到不再用的变量，释放其占的内存。存在两种变量：局部和全局。全局生命周期持续到页面卸载；局部声明在函数中，生命周期从函数执行开始到执行结束，过程中，局部变量在堆或栈中存它们的值，函数执行结束后，这些局部变量不再被用，所占空间会被释放。不过，当局部变量被外部函数使用时(闭包)，函数执行结束后，函数外部变量依然指向函数内部局部变量，此时局部变量不会回收。 回收方式：标记清除，引用计数。</p><p>标记清除隔一段时间遍历清除，引用计数是立即清除，需要计数器且不知道上限且有循环引用问题。 1）标记清除变量进入执行环境时，标记“进入环境”，被标记为“进入环境”的变量不能回收。变量离开环境，标记为“离开环境”，标记“离开环境”的变量被内存释放。垃圾收集器运行时给内存中的所有变量都加上标记。然后去掉环境中的变量(全局变量)以及被环境中的变量引用的标记(局部变量被引用)。之后再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁带标记的值并回收他们所占的内存空间。机制运行时候找被某块内存直接引用和间接引用的对象，打上标记，没有标记的清除。，清理后内存碎片化，下一次分配空间需要遍历所有的判断size大于等于值再分配。v8优化添加标记整理，空内存整理到一边，清理边界内存。 2）引用计数跟踪记录每个值被引用次数。当声明一个变量并将一个引用类型赋给该变量时，这个值引用次数是 1。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减 1。当引用次数为 0 ，下次回收时，这个变量所占内存空间会被释放。引用表记录引用次数，当某块内存不再被引用，次数减一，为0时立即清除。但是会有循环引用的问题，需要最终手动设为null。 循环引用问题：如：obj1和obj2通过属性相互引用，两对象引用次数都是 2。用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2将会继续存在，它们引用次数永远不会是 0，引起循环引用。 function fun() { let obj1 = {}; let obj2 = {}; obj1.a = obj2; // obj1 引用 obj2 obj2.a = obj1; // obj2 引用 obj1 } 手动释放内存： obj1.a = null obj2.a = null 减少垃圾回收。数组优化：清空数组，赋[]会创建新的空对象。将数组长度设 0。object优化：对象复用，不再用的对象设为 null。函数优化：循环中的函数表达式，可复用放函数外面。 内存泄漏：意外的全局变量：用未声明的变量，意外创建全局变量，一直留在内存无法回收。遗忘的计时器或回调：setInterval 忘取消，如果循环函数有对外部变量的引用的话，那这个变量会被一直留在内存，无法被回收。脱离 DOM 引用：获取 DOM 引用，后面这个元素被删除，由于一直保留对这个元素的引用，所以无法回收。闭包：不合理的闭包导致某些变量一直被留在内存当中。意外的全局变量没有手动置空、未清理的计时器、回调函数、不恰当的闭包、console.log()、遗忘的事件监听、map set对象强引用建议用WeakMap、未清理的dom元素引用 所以，基本类型具有不可变性，变量重新赋值是在栈中开辟新内存空间存值，即将变量指向新内存空间，原来的还在会被垃圾回收机制回收。两者互不影响。引用类型复制是栈中开辟新内存空间存新地址，新旧地址指向堆中同一个实体，互相影响，也叫浅拷贝，只拷贝地址没有拷贝地址对应的对象。函数传参时候基本类型传值，引用类型传地址。而深拷贝会开辟新空间，并拷贝源地址对应的对象，新旧指针指向不同的实体数据，互不影响。</p><p>v8优化 新生代：分为使用区、空闲区。使用区快满时，标记活动对象，复制到空闲区并排序，清理非活动对象，调换两个区域。当某对象复制到空闲区占用超过25%或多次复制后存活的对象放入老生区 老生代：原有的标记清除+标记整理算法+全停顿标记改为增量标记</p><p>为什么： 字符串、对象和数组没有固定大小，当他们大小已知时，才能对他们动态存储分配。JSc 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 JS 不像 C/C++，有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如： var a=&quot;hello world&quot;; var b=&quot;world&quot;; var a=b;//这时，会释放掉&quot;hello world&quot;，释放内存以便再引用</p><p>标记清除(常见) 变量进入环境时，就标记这个变量为进入环境，永远不能释放带有进入环境标记的变量，当离开环境时，就标记为离开环境 过程:垃圾回收器在运行时给存储在内存中的变量都加上标记，去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成内存清除，回收他们所占内存。</p><p>引用计数 每个值设引用的次数 当声明一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为 1,；相反，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没办法再访问这个值，就把所占内存给回收进来，垃圾收集器再次运行时，会释放引用次数为 0 的值。</p><p>缺点：内存泄露 function problem() { var objA = new Object();var objB = new Object();objA.someOtherObject = objB;objB.anotherObject = objA;} 在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。 特别是在 DOM 对象中，也容易存在这种问题： var element=document.getElementById（’‘）；var myObj=new Object();myObj.element=element;element.someObject=myObj;这样就不会有垃圾回收的过程。</p><p>V8 下的垃圾回收机制</p><p>V8 实现准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。 新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 在讲算法前，先来说下什么情况下对象会出现在老生代空间中： • 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 • To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 老生代中的空间很复杂，有如下几个空间</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AllocationSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // TODO(v8:7464): Actually map this space&#39;s memory as read-only.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不变的对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新生代用于 GC 复制算法的空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OLD_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代常驻对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CODE_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代代码对象空间</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MAP_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代 map 对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 老生代大空间对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新生代大空间对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    FIRST_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LAST_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NEW_LO_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FIRST_GROWABLE_PAGED_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OLD_SPACE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LAST_GROWABLE_PAGED_SPACE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MAP_SPACE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在老生代中，以下情况会先启动标记清除算法： • 某一个空间没有分块的时候 • 空间中被对象超过一定限制 • 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>`,46),p=[e];function t(h,k,r,o,d,E){return a(),i("div",null,p)}const g=s(l,[["render",t]]);export{b as __pageData,g as default};
