import{_ as s,o as i,c as a,a5 as n}from"./chunks/framework.DnJ-_PtE.js";const E=JSON.parse('{"title":"vuex","description":"","frontmatter":{},"headers":[],"relativePath":"pc/vue/vuex.md","filePath":"pc/vue/vuex.md","lastUpdated":1718184414000}'),e={name:"pc/vue/vuex.md"},t=n(`<h1 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;vuex&quot;">​</a></h1><blockquote><p>概念：状态管理仓库，以<strong>单例模式</strong>存放数据，集中式管理所有组件的状态，同时利用Vue.js的响应式机制实现数据视图的更新 场景： 数据在多个组件来回调用比如用户信息、websocket、全局使用且不被浏览器清理 缺点: 耦合性高，不持久、刷新会丢失数据，不符合高内聚低耦合原则</p></blockquote><h2 id="为什么会出现vuex-redux这些状态管理库" tabindex="-1">为什么会出现vuex redux这些状态管理库 <a class="header-anchor" href="#为什么会出现vuex-redux这些状态管理库" aria-label="Permalink to &quot;为什么会出现vuex redux这些状态管理库&quot;">​</a></h2><p>以单例模式管理，方便多层嵌套组件，兄弟组件间状态传递</p><h2 id="解决页面刷新数据丢失" tabindex="-1">解决页面刷新数据丢失 <a class="header-anchor" href="#解决页面刷新数据丢失" aria-label="Permalink to &quot;解决页面刷新数据丢失&quot;">​</a></h2><ol><li>localStorage保存</li><li>vuex-along插件</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state:{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> plugins: [vuexAlong]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="基本概念及使用" tabindex="-1">基本概念及使用 <a class="header-anchor" href="#基本概念及使用" aria-label="Permalink to &quot;基本概念及使用&quot;">​</a></h2><ol><li>state 基本数据(共享数据源)</li><li>getters 读取器，从基本数据派生出来的数据，读数据或在读之前做一些计算</li><li>mutations 修改器，参数state,唯一修改state中值的方法，类似事件，<strong>同步</strong>,由commit触发</li><li>actions 装饰器，包裹mutations，<strong>异步</strong>，向store发出调用通知、理解成store的methods,可异步， 提交的是 mutation，不是直接变更状态</li><li>modules 模块化Vuex</li></ol><p><strong>工作流程</strong></p><ul><li>Components 触发（dispatch）事件（Actions）</li><li>组件get/set data， vuex 中数据是集中管理，不能直接改，把Actions动作提交Commit到 Mutations;</li><li>Mutations 改变State 中数据; 只能同步，因为每个mutation执行完后会对应一个新的状态变更，这样可以打快照存下来，实现 time-travel 了，如果支持异步，就没办法知道状态何时更新，无法状态追踪。</li><li>State 中数据改变后，重新Render Components组件展示更新后的数据。</li></ul><p><strong>原理</strong></p><ol><li>通过vue.mixin 将 vuexInit 混进 beforeCreate 钩子函数，每个vm实例都会调 vuexInit</li><li>从当前组件的options拿到store方法执行</li><li>在根实例中把store 赋值给<code>$store</code>,并利用vue组件加载的先父后子原则，从根实例的子组件开始，每个组件都从父组件拿到<code>$store</code>,并将从父组件拿到的<code>$store</code> 赋值给自己的<code>$store</code>属性，从而实现每个组件都拥有<code>$store</code>属性，并且都指向同一个store实例</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vuexInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// this指向vue,  this.$options指向调用初始化 Vue 时候传入的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$options</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//  判断对象是否传入store</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (options.store) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 如果有说明store是根节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options.store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options.store</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (options.parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options.parent.$store) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		//否则从父节点store获取</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options.parent.$store}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vuex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _Vue</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//  vue.mixin 将 vuexInit 混进 beforeCreate 钩子函数，每个vm实例都会调 vuexInit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mixin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ beforeCreate: vuexInit })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vuex)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="和-localstorage-区别" tabindex="-1">和 localStorage 区别 <a class="header-anchor" href="#和-localstorage-区别" aria-label="Permalink to &quot;和 localStorage 区别&quot;">​</a></h2><ul><li>vuex存内存, 用于组件间传值，能响应式，刷新页面会丢失。</li><li>localstorage 以文件方式存本地，只能存字符串类型，存对象需要 JSON的stringify和parse方法处理。 不能响应式，刷新页面不会丢失</li></ul><p>读内存比读硬盘速度快。</p><h2 id="和-redux-区别" tabindex="-1">和 Redux 区别 <a class="header-anchor" href="#和-redux-区别" aria-label="Permalink to &quot;和 Redux 区别&quot;">​</a></h2><p>● Vuex 改进 Redux 中的 Action 和 Reducer 函数，以 mutations 变化函数取代 Reducer，无需 switch，只需在对应的 mutation 函数里改变 state 值即可</p><p>● Vuex 由于 Vue 自动重新渲染特性，无需订阅重新渲染函数，只要生成新的 State 即可</p><p>● Vuex 数据流顺序 ∶View 调用 store.commit 提交对应请求到 Store 中对应的 mutation 函数-&gt;store 改变（vue 检测到数据变化自动渲染） vuex 弱化 dispatch，通过 commit 进行 store 状态的一次更变;取消了 action 概念，不必传入特定的 action 形式进行指定变更;弱化 reducer，基于 commit 参数直接对数据进行转变，使得框架更加简易; 共同</p><p>● 单—数据源 ● 变化可预测</p><p>本质：都是 mvvm 思想，数据从视图中抽离; 形式：vuex 借鉴 redux，将 store 作为全局的数据中心，进行 mode 管理;</p>`,23),l=[t];function p(h,r,k,o,d,u){return i(),a("div",null,l)}const g=s(e,[["render",p]]);export{E as __pageData,g as default};
