import{_ as s,o as i,c as a,a5 as n,af as l,ag as p,ah as t,ai as e}from"./chunks/framework.DnJ-_PtE.js";const m=JSON.parse('{"title":"操作系统","description":"","frontmatter":{},"headers":[],"relativePath":"computed/os.md","filePath":"computed/os.md","lastUpdated":1718184414000}'),h={name:"computed/os.md"},k=n('<h1 id="操作系统" tabindex="-1">操作系统 <a class="header-anchor" href="#操作系统" aria-label="Permalink to &quot;操作系统&quot;">​</a></h1><blockquote><p>操作系统一些概念：大部分操作系统(Windows、Linux)的任务调度采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(并发简单来说多个任务同时执行)。计算机核心CPU负责所有计算任务；操作系统是个软件，负责任务的调度、资源分配，统领整个计算机硬件；应用程序也就是进程是具有某种功能的程序，程序是运行于操作系统之上。</p></blockquote><p><img src="'+l+'" alt="os"></p><h2 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h2><h3 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h3><p>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。 CPU分配资源的最小单位 想用CPU资源或内存资源要开个进程，一个CPU同一时间内只能执行一个任务，运行一个进程。多进程通过时间片轮换实现。</p><p>进程可以看作是一个程序的执行实例，有自己独立的内存空间、资源和执行环境。</p><h3 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h3><p>CPU调度最小单位，一个进程可包含多个线程，这些线程共享进程的资源，启动浏览器后，打开管理器，发现chrome有11个进程。浏览器是多进程的架构，每个页面是一个进程，为了保证网页卡死不是进程崩溃。 线程则是进程中的执行单元，它们共享进程的资源，但又能独立执行不同的任务。线程的存在使得进程能够同时进行多个操作，极大地提高了效率。</p><h3 id="关系" tabindex="-1">关系 <a class="header-anchor" href="#关系" aria-label="Permalink to &quot;关系&quot;">​</a></h3><p>浏览器和node都是多进程，浏览器通过主进程控制其他进程，node通过cluster创建多个子进程 我们写的JS代码根据宿主环境的不同，能用的API也不同，浏览器进程会暴露接口让JS获取浏览器相关信息以及操作DOM，Node上JS通过fs模块管理操作系统上的文件，所以一般node写服务端，浏览器写客户端，不同的宿主环境事件循环机制也不同 浏览器端：JS代码由JS引擎线程逐行解析执行，JS引擎线程会把代码转为01字符串，也就是操作系统能识别的机器指令，然后交给CPU去计算，CPU只能认识自己的指令集，也就是包含0和1的机器语言，CPU计算完后将结果写回内存，0101格式，这个不是字符串，而是硬件之间通过电信号传输的高低电平， 当代码中用到这个变量，也就是读操作，会通过进程向操作系统发起读文件请求，拿到数据 操作系统是进行软硬件资源管理的软件，作为桥梁，向上对接应用层，进程，向下对接硬件CPU 操作系统提供API让浏览器或NOde与cpu内存进行交互, 读写数据, 在需要的时候调用硬件将数据绘制在屏幕上</p><p><img src="'+p+`" alt="os1"></p><p>● 进程是操作系统分配资源的基本单位：进程有独立内存空间，包括代码、数据和进程控制块。</p><p>● 线程是进程中的执行单元：一个进程可包含多个线程，它们共享进程的资源，如内存空间、文件等。</p><p>● 线程间相互独立：每个线程有自己的程序计数器、栈和状态，能独立执行代码。</p><p>● 线程共享进程资源：线程可以访问进程中的共享数据，如全局变量、静态变量等。</p><p>● 进程与线程区别：线程是程序执行的最小单位，进程是操作系统分配资源的最小单位；一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；进程间相互独立，同一进程下的各个线程之间共享程序的内存空间（包括代码段，数据集，堆等）及一些进程级的资源（如打开文件和信号等）。</p><h2 id="堆与栈" tabindex="-1">堆与栈 <a class="header-anchor" href="#堆与栈" aria-label="Permalink to &quot;堆与栈&quot;">​</a></h2><blockquote><p>理解堆和栈要分场景 （1）程序内存场景下，表示两种内存管理方式，操作系统为了更好的管理、分配内存，将内存分为栈和堆，本质上就是为了不造成空间浪费，开发时候也要及时清除避免内存泄漏造成溢出 （2）数据结构场景下，表示两种常用的数据结构，详细可以看数据结构章节，本文只站在程序内存分区的角度理解</p></blockquote><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈，比如</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>函数中定义的局部变量按照先后定义的顺序依次压入栈中 栈中存储的数据的生命周期随着函数的执行完成而结束 <img src="`+t+'" alt="stack"></p><h3 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h3><p>由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表 ps：JS引擎的垃圾回收机制就是为了避免开发者忘记释放堆内存</p><p>内存空间地址是不连续的，会在栈中存指针，堆中存实体</p><p>堆上内存空间分配过程：首先操作系统有个记录空闲内存地址的链表，系统收到程序的申请时，遍历链表，找第一个空间大于所申请空间的堆节点，将该节点从空闲节点链表中删除，将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。 <img src="'+e+`" alt="heap"></p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p>堆与栈是操作系统对进程占用内存空间的两种管理方式</p><p>（1）管理方式不同。栈由操作系统自动分配释放，无需手动控制；堆申请和释放由程序员控制，容易产生内存泄漏；</p><p>（2）空间大小不同。每个进程栈大小远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p><p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p><p>（4）分配方式不同。堆是动态分配。栈有 2 种分配方式：静态和动态。静态是由操作系统完成，如局部变量的分配。动态分配由alloca()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。</p><p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆效率比栈要低。</p><p>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><p>从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。 栈相比于堆，应用较为广泛，常见的函数调用过程由栈实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p><p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，</p><p>读到这里，就理解了为什么JS引擎会有垃圾回收机制，可以去看看</p><p>栈和堆是数据结构，分别用于存储线程的局部数据和进程的动态分配内存。多线程编程中，合理使用栈和堆，并注意线程间同步问题，确保程序正确性和性能。</p><p>● 栈是线程私有的：栈用于存储线程的局部变量、函数参数和返回地址等。每个线程有自己独立的栈，线程的执行过程就是栈的入栈和出栈过程。</p><p>● 堆是进程共享的：堆用于存储进程运行中动态分配的内存，如对象实例。堆大小可以动态调整，由操作系统自动管理。</p><p>● 线程操作栈不需要同步：每个线程都有自己独立的栈。</p><p>● 线程操作堆可能要同步：如果多个线程同时操作堆中的共享数据，可能会导致数据不一致，需要同步操作，确保线程之间的协调和数据的正确性。</p><p>编写代码过程中，定义变量，函数参数等都是在给其分配内存空间</p><h2 id="linux命令" tabindex="-1">linux命令 <a class="header-anchor" href="#linux命令" aria-label="Permalink to &quot;linux命令&quot;">​</a></h2><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ssh name@server   登录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">创建目录 mkdir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">目录名称</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">删除目录 rm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">目录名称</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定位目录 cd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">目录名称</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">查看目录文件 ls ll</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">修改目录名 mv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">目录名称</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">新目录名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">拷贝目录 cp &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">目录名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">新目录名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">创建文件 touch &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; vi &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">删除文件 rm &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">修改文件名 mv &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">新文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">拷贝文件 cp &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">新文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">查看文件 cat &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; head &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; tail &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">编辑文件内容 vi &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">查找文件内容 grep &#39;关键字&#39; &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">文件名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div>`,46),r=[k];function E(d,c,o,g,b,y){return i(),a("div",null,r)}const C=s(h,[["render",E]]);export{m as __pageData,C as default};
