import{_ as r,o,c as d,j as e,a as t,t as i,a5 as p}from"./chunks/framework.DnJ-_PtE.js";const S=JSON.parse('{"title":"构建工具","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/buildTool.md","filePath":"engineering/buildTool.md","lastUpdated":1718254561000}'),s={name:"engineering/buildTool.md"},n=p('<h1 id="构建工具" tabindex="-1">构建工具 <a class="header-anchor" href="#构建工具" aria-label="Permalink to &quot;构建工具&quot;">​</a></h1><h2 id="理解" tabindex="-1">理解 <a class="header-anchor" href="#理解" aria-label="Permalink to &quot;理解&quot;">​</a></h2><p>“构建”也可理解为“编译”，将开发环境的代码转换成运行环境代码的过程。开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况： 处理模块化：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定 的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用webpack、Rollup 等处理 JS 模块化。 编译语法：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 代码压缩：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。</p><p>最早普及使用的构建工具是 Grunt ，不久又被 Gulp 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。 如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。</p><h2 id="构建工具选型" tabindex="-1">构建工具选型 <a class="header-anchor" href="#构建工具选型" aria-label="Permalink to &quot;构建工具选型&quot;">​</a></h2><table><thead><tr><th>名称</th><th>特点</th><th>配置文件</th></tr></thead><tbody><tr><td>grunt</td><td>自动化，配置反复重复的任务，如压缩、编译、测试，一切皆配置</td><td>Gruntfile.js</td></tr><tr><td>glup</td><td>基于 node 的流打包工具，定义多个 task 及顺序，流式写法，异步的，顺序难控制</td><td>glupfile.js</td></tr><tr><td>webpack</td><td>模块化管理和打包工具，loader 转换文件，按需加载</td><td>webpack.config.js</td></tr><tr><td>rollup(vite)</td><td>下一代的 ES6 模块化工具，treeshaking，js 类库适用，ES6 写代码，减少死代码缩小包体积，但是不利于静态资源，代码拆分</td><td>rollup.config.js</td></tr><tr><td>parcel</td><td>快速，零配置，只用来构建运行在浏览器中的网页，无需依赖，以 html 为入口，自动检测打包依赖资源，默认 HMR，不支持 sourcemap treeshaking</td><td>无</td></tr></tbody></table><h2 id="vite-和-webpack-区别" tabindex="-1">Vite 和 webpack 区别 <a class="header-anchor" href="#vite-和-webpack-区别" aria-label="Permalink to &quot;Vite 和 webpack 区别&quot;">​</a></h2><p>● vite由两部分组成： ○ 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新 HMR ○ 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源 作用类似 webpack+ webpack-dev-server，特点： ● 快速冷启动 ● 即时的模块热更新 ● 真正的按需编译</p><p>vite 直接启动开发服务器，不需要打包，意味着不需要分析模块依赖、不需要编译，因此启动速度快。 利用现代浏览器支持 ES Module 的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间。</p><p>● 区别在热模块 HMR 方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像 webpack 那样需要把该模块的相关依赖模块全部编译一次，效率更高。</p><h2 id="vite为什么快" tabindex="-1">vite为什么快 <a class="header-anchor" href="#vite为什么快" aria-label="Permalink to &quot;vite为什么快&quot;">​</a></h2><p>开发环境用ES6module，无需打包直接引用。生产环境用rollup。webpack是打包成es5。</p>',12),c=e("code",null,"children[{}]",-1),l=e("p",null,[t("或者toRefs(state)把每一项都变成ref对象。导出"),e("code",null,"...toRefs(state)"),t(" 计算属性computed 创建一个新响应式数据，依赖于其他属性 computed的value是只读的 想改：做set监听 watchEffect 依赖谁改变才会变 区别 计算属性依赖的值，计算新值 watch监听现有的值 第一次不输出，值改变后才会输出 "),e("code",null,"watch(值，(){})")],-1);function u(a,h,v,f,m,b){return o(),d("div",null,[n,e("p",null,[t("get:依赖收集。组件1data有一个a属性，a属性更改后要把所有页面更新一次。a只在一个组件用，没必要更新所有组件，改进：哪里使用a就更新哪里。怎么知道哪里用a 初始化vue对象，会触发get收集依赖，dep.depend() set更新视图，调用dep.notify方法，把收集的依赖做更新 3不用defineProperty() ，用proxy，不支持ie8 defineProperty() 针对对象每一个属性，有多少就调用多少次，每一个调用会降低性能 proxy是new一个对象，得到代理对象，操作代理对象，触发getset，不改变原对象。提升初始化响应式性能。 根本区别：一个在原对象改，一个在代理对象上操作，proxy解决了数组响应式，新增动态添加响应式问题，2里面调用push方法才能触发响应式，不能监听动态变化，因为defineProperty() 针对对象，数组不是对象。proxy可以直接修改数组下标触发响应。 diff算法:比对新老的虚拟dom virtual dom 比对前已经生成新的虚拟dom,再比对。虚拟dom并不是真实dom，可以看作一个对象，第一层是他的父级元素。 4个要素：节点类型type,文字节点text，属性attribute，子节点"),c,t(" 树状结构AST语法树的衍生，最外层就是根 diff算法为什么要比对新老的虚拟dom？更新DOM时怎么更新成本最小？只改文字还是删除重新渲染？ 如果是type变，直接删了重新创建；如果是文字，直接修改；如果节点下有个key值，删了重新创建，所以要保证key值稳定，key不能用index 2比对会一个一个比对，每个dom都要比一次。但是比如h1标签本身不会改变，因为它上面没有绑定任何vue指令。他会把不可能变的都要比一次。 3比对次数更少，比对之前会筛选出动态节点标记为1，静态节点标记0，只比对标记为1的 3把静态的标签放在了render外面，初始化就创建，不会把不变的再创建，把它缓存下来，高效利用缓存 为什么块6倍数？proxy diff render react diff算法：整个比对过程做时间切片，并行或者串行 v3实战 vite 类似webpack,是构建工具，用来打包 vite1.0只支持vue3 webpack核心：打包，其他功能通过插件实现 打包：开发必须要模块化import，浏览器又不认识import，所以要通过webpack从入口文件分析成引用树，放在一个文件中，把import代码转换成可以执行的代码 开发必须要模块化import，浏览器又不认识import，vite不用打包，使用esm可以直接跑， esm写script标签，加type=moudle，不用编译 import 好处：节约打包时间 esm只有现代浏览器支持，不兼容 可以用vite开发，上线时用webpack打包 vue3新特性 vite+vue3初始化 新写法 没有node moudle和router,安装依赖，加路由 3里面怎么加路由,注意版本 vue-router@next vuex@next 3的编码是函数式编程，路由也要函数式编程 旧：import vue router new rules 新：调用方法创建，createRouter({routes:[]}) 更支持history export 对象 写法 完全支持vue2,向下兼容 vue3生命周期没有create beforecreate被setup代替 一个变量ref 对象reactive() setup里面没有this,它的this指向undefined ref要.value 复杂的用reactive() 组合一系列方法的调用，从vue调入一些方法，直接使用。。。之前2都是写在对象上 3父子传值 props参数 setup（props） 3子父传值 setup(props,contex) contex.emit contex相当于this 3provide方法 定义变量 provide('a','111) 子组件中直接用inject('a') 跨组件传值 2写法弱点：当组件复杂度增加，维护难度也会增加，同一个功能是散布的。逻辑不能直接拿出去作为独立的JS代码，还保留this指向。 3相当于react里的class hook，，加强了ts的支持 vue3+ts react+ts+hook 性能提高 重写DOM，diff算法 只更新更改的DOM 2中全部对比，3中静态节点初始化之后只比较动态绑定的 nuxt.js webpack打包体积 所有方法只使用了部分，只打包需要的 允许有多个根节点，使得层次更浅 更好的TS支持，本质采用后台思想，例如java composition 把组件写的东西渲染到画布上而不是渲染到dom Proxy 响应式数据代替原有的defineprop，监听劫持proxy es6，改写了数组的7个方法 语法： 整体推荐函数式编程，更强大的功能：传送文：制定某些东西放入某地方，更好的渲染canvas 很少有new... 大部分从vue vue-router解构出对应的函数 聚合式API 以前放入Option API中，现在用setup,聚合API setup拿到props属性,context setup还没有创建好组件实例，所以不能用this setup中return啥，事物中直接用 响应式数据怎么做？ definePro ref创建响应式对象 从vue解构出ref ref(0)括号里写初始值，几个状态写几次 通过ref创建出来的状态是一个对象，对其中的value做了get和set监听 js中用.value获取值 视图中："),e("code",null,i(a.state),1),t(" 后续修改状态时 reactive 从vue解构出reactive 比如执行一个方法创建多个状态 get set has ownkeys代理 reactive返回代理对象")]),l])}const _=r(s,[["render",u]]);export{S as __pageData,_ as default};
