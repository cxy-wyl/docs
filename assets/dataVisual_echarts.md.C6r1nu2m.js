import{_ as e,o as a,c as t,a5 as r}from"./chunks/framework.DnJ-_PtE.js";const u=JSON.parse('{"title":"Echarts坑","description":"","frontmatter":{},"headers":[],"relativePath":"dataVisual/echarts.md","filePath":"dataVisual/echarts.md","lastUpdated":1717756482000}'),s={name:"dataVisual/echarts.md"},l=r('<h1 id="echarts坑" tabindex="-1">Echarts坑 <a class="header-anchor" href="#echarts坑" aria-label="Permalink to &quot;Echarts坑&quot;">​</a></h1><p>使用v-show来切换图标的显示隐藏，图标显示不正常 当饼图的数据很多时，图例显示过多，覆盖了饼图时，设置type: &#39;scroll&#39;,可以对图例进行分页 图例的icon支持base64格式</p><p>首先优化Echarts，我会有两个方向，一个是开源，一个是节流，开源就是提高我的cpu的渲染效率，也有就是说我去减少我的绘画的一个数据量，那首先我从开源的这个角度上来讲的话，我第一个想到的一个就是用web worker，它相当于是我可以在这个阶段去新开一个线程去进行这个Eacharts绘图的一个渲染，然后截流这一块呢，就是首先我可以做一个懒加载，这个是比较粗暴的一个做法，然后更细化的话呢，其实它在具体绘图的时候，有很多的配置项是可以优化的，比如说它的eacharts的点是可以进行抽样绘制的，然后在eacharts的那个，因为就算你抽样之后，它可能还是有几个点堆在一起特别密的情况，这个时候他可以去进行一些算法的优化，比如说eacharts有一个算法lttb是他去通过这个eacharts的一个这个点的前一个点和后一个点，他去绘一个三角形，然后去判断这个三角形的面积是不是大于一个阈值（两点间的距离，若小于该值可以忽略），然后去优化它的绘画算法，最后解决了这个问题之后，我们会把效率得到一个比较高的一个提升。</p><h1 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h1><p>从全量加载改为增量加载，减少首次渲染数据量。</p><ol><li>全量加载 全部删除后再进行全部(全量)数据加载。技术角度来说，全量加载比增量加载简单。只需在数据加载前将目标表清空，再将源数据表中的数据导人。但是，由于实时性的要求，很多情况下都需要使用增量加载。</li><li>增量加载 目标表仅更新源数据表中变化的数据。关键是设计相应的方法，用于从源数据表中抽取增量的数据，以及变化“牵连”数据(虽没有变化，但受到变化数据影响的数据)。同时，将这些变化的和未变化但受到影响的数据，在完成相应的逻辑转换后更新到数据仓库中。 ETL增量加载类似于增量抽取，有时间戳方式、日志表方式、全表对比方式、全表删除插入方式 (1)时间戳方式，即在业务表中统-添加-个字段作为时间戳，当联机分析处理(OLAP)系统更新修改业务数据时，同时也会修改时间戳字段值，这时就将更新修改的数据加载到目标表中。 (2)日志表方式，即在OLAP系统中添加日志表，业务数据发生变化时，更新维护日志表内容。 (3)全表对比方式，即抽取所有源数据，在加载目标表之前先根据主键和字段进行数据比对，有更新的数据就进行更新或插入。 (4)全表删除插入方式，删除目标表中的数据，将源数据表中的数据全部加载到目标表中。</li></ol><h2 id="降采样lttb算法" tabindex="-1">降采样lttb算法 <a class="header-anchor" href="#降采样lttb算法" aria-label="Permalink to &quot;降采样lttb算法&quot;">​</a></h2><p>最大三角形算法，主要是找出代表那个桶的点 1） 首先确定桶的大小，将数据点平分到桶中，注意首尾点各占一个桶确保选中 2） 其次计算每个点和邻接点形成的有效区域，去除无有效区域的点 3） 在每个桶中选取有效区域最大的点代表当前桶 3） 从第二个桶开始，遍历桶中的点，计算每个点的有效区域，并选取有效区域最大的点作为桶的代表点。三角形的选取为[前一个桶的选中点，当前点，后一个桶的平均点]。 同时固定三角形的两个点， 通过 Echarts 的 sampling 功能，使用 lttb 算法进行采样点优化，提高绘图效率。 ‘average’ 取过滤点的平均值 ‘max’ 取过滤点的最大值 ‘min’ 取过滤点的最小值 ‘sum’ 取过滤点的和</p><p>illb ● 点 A，预选点 ● 点 B，和 ABC 组成的三角形面积最大的点 ● 点 C，C 桶数据点的平均点 按照上述逻辑，继续把 B 点当成第一个点作为预选点，已知。D 桶（图中未给出）中选取临时点 D 点，从而计算出 C 桶中真正能代表 C 桶的 C 点。 依次循环遍历，完成所有桶的逻辑计算。</p><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><p>关闭动画以加快渲染速度 series-line. showAllSymbol = ‘auto’只在主轴为类目轴（axis.type 为 ‘category’）时有效。 可选值： ‘auto’：默认，如果有足够空间则显示标志图形，否则随主轴标签间隔隐藏策略。 true：显示所有图形。 false：随主轴标签间隔隐藏策略。 series-line. animation = true 是否开启动画。 series-line. showSymbol = true 是否显示 symbol, 如果 false 则只有在 tooltip hover 的时候显示。 <a href="https://www.freesion.com/article/44031377453/" target="_blank" rel="noreferrer">https://www.freesion.com/article/44031377453/</a><a href="https://blog.csdn.net/weixin_43180359/article/details/103972649" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_43180359/article/details/103972649</a><a href="https://blog.csdn.net/weixin_43443341/article/details/109099455" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_43443341/article/details/109099455</a> echarts图位置变小，变形之后还出现卡顿现象。<a href="https://juejin.cn/post/7036177574514393119#heading-4" target="_blank" rel="noreferrer">https://juejin.cn/post/7036177574514393119#heading-4</a> 拖拽卡顿，加载慢</p>',11),i=[l];function o(n,c,h,d,p,_){return a(),t("div",null,i)}const f=e(s,[["render",o]]);export{u as __pageData,f as default};
