import{_ as e,o as a,c as t,a5 as r,am as o,an as i}from"./chunks/framework.DnJ-_PtE.js";const M=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[],"relativePath":"pc/index.md","filePath":"pc/index.md","lastUpdated":1718184414000}'),p={name:"pc/index.md"},l=r('<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><p>PC端宿主环境是浏览器 组件化开发：业务解耦 模块化开发：功能划分</p><h2 id="mvvm-mvc-mvp" tabindex="-1">MVVM MVC MVP <a class="header-anchor" href="#mvvm-mvc-mvp" aria-label="Permalink to &quot;MVVM MVC MVP&quot;">​</a></h2><p>早期的组件化：php jsp node.js, node后端模板渲染针对页面中某个组件模块传入该模块的数据信息，组件相同，数据不同</p><p>vue React组件化：给组件绑定变量传递信息</p><p>vue react优势在于：传统组件只是静态渲染，页面数据更新依赖于操作dom, 当时比较流行jquery。现在vue通过mvvm, react通过setState完成数据驱动视图，不再需要手动操作dom, 只需要更新数据</p><p>JQuery 时期，如果要刷新 UI ，要先取到对应 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。</p><p>MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。</p><p>高内聚低耦合，mvc-mvp-mvvm不断降低model和view耦合度的过程。</p><h3 id="mvc" tabindex="-1">mvc <a class="header-anchor" href="#mvc" aria-label="Permalink to &quot;mvc&quot;">​</a></h3><p>观察者模式，Controller 只知道 Model 接口，没办法直接控制 View 层更新，Controller改Model, Model再通知View层。</p><p>view和model直接联系，view触发controller中事件，事件回调修改model数据，model手动操作dom进行视图更新，view和model耦合性高，联系紧密。</p><h3 id="mvp" tabindex="-1">mvp <a class="header-anchor" href="#mvp" aria-label="Permalink to &quot;mvp&quot;">​</a></h3><p>View 层接口暴露给 Presenter ，因此 Presenter 中将 Model 变化和 View 变化绑定在一起，实现 View 和 Model 同步更新。实现对 View 和 Model 的解耦。</p><p>通过 Presenter代替Controller将 View 和 Model 解耦。view和model通过Presenter联系，MVC 的 Controller 只知道 Model 接口，没法控制 View，MVP中View接口给 Presenter，Presenter 将 Model 和 View 绑一起，实现 View 和 Model 同步更新。但一个Presenter只能绑一个view，因为每个View都要独立的Presenter处理，如果一个Presenter绑多个View，View更新时，Presenter需要知道所有的View，并对每个View进行更新，降低可读性和可维护性。而mvvm一个viewmodel可绑多个view他们共享相同的数据和状态，vue源码get时依赖收集当Model变化，所有与该ViewModel绑定的View自动更新。ViewModel是独立的类，唯一职责是表示一个View后面的数据。意味着同一个ViewModel可用于多个不同的View，提高复用性。</p><h3 id="mvvm" tabindex="-1">mvvm <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;mvvm&quot;">​</a></h3><p>Model和View无直接关联，通过ViewModel联系</p><p>view和model无关联，通过viewModel联系，viewModel理解成vue实例，初始化时把数据挂在vue实例上，给每个数据添加get和set方法，get里面收集依赖也就是订阅用到当前数据的其他对象，set里通知之前的订阅者更新数据。首次渲染会触发get进行订阅，后续更改触发set，set通知订阅者也就是dom进行更新，更新时通过比较虚拟dom达到最小化更新，底层是基本dom操作，这样开发者就只关注数据就可。view层通过指令触发事件，事件回调修改vue实例上的数据，vue实例帮我们更新dom，由于浏览器渲染机制每次操作dom会重排，vue内部通过虚拟dom减少操作dom的数量，通过nexttick减少操作dom的频率。</p><p><img src="'+o+'" alt="mvvm"><img src="'+i+'" alt="mvvm1"></p><h3 id="脏数据检测" tabindex="-1">脏数据检测 <a class="header-anchor" href="#脏数据检测" aria-label="Permalink to &quot;脏数据检测&quot;">​</a></h3><p>当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二 次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p><h3 id="数据劫持" tabindex="-1">数据劫持 <a class="header-anchor" href="#数据劫持" aria-label="Permalink to &quot;数据劫持&quot;">​</a></h3><p>Vue 内部使用了 Obeject.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。 在适当的时候给属性添加发布订阅 核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。</p><h2 id="vue-react-angularjs-jquery" tabindex="-1">Vue React angularjs jquery <a class="header-anchor" href="#vue-react-angularjs-jquery" aria-label="Permalink to &quot;Vue React angularjs jquery&quot;">​</a></h2><p>JQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动。 JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。 Angular，Vue 是双向绑定，而 React 不是</p><p>抽离公共逻辑：mixin composition api解决复用 react hooks</p><p>数据驱动视图(响应式): 数据劫持 发布订阅 不能监听数组要重写 嵌套对象要深度监听 vue3 proxy 兼容性差不能polify react setState</p><h2 id="angularjs-和-react" tabindex="-1">angularJs 和 React <a class="header-anchor" href="#angularjs-和-react" aria-label="Permalink to &quot;angularJs 和 React&quot;">​</a></h2><p>React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化，分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素，利用组件概念进行分治管理页面每个部分(例如 header section footer slider)</p><h2 id="react-和-vue" tabindex="-1">React 和 Vue <a class="header-anchor" href="#react-和-vue" aria-label="Permalink to &quot;React 和 Vue&quot;">​</a></h2><p>相似： ● 注意力集中在核心库，其他功能如路由和全局状态管理交给相关库； ● 有自己的构建工具，项目模板； ● 都用虚拟 DOM 提高重绘性能；都有 props 的概念，允许组件间数据传递； ● 组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</p><p>不同 ： 1）数据流 Vue 默认数据双向绑定，React 提倡单向数据流</p><p>2）虚拟 DOM Vue采用基于依赖跟踪的响应式系统，跟踪每个组件依赖关系，不需重新渲染整个组件树。数据变化时，Vue创建新的虚拟节点树与旧的节点树对比，找出需要更新的节点更新。这种策略数据小的情况下表现良好，但在处理大量数据或复杂渲染时可能会出现性能问题。 React基于组件更新机制，数据发生变化时，全部子组件都重新渲，React根据组件的props和state重新创建整个虚拟DOM树，并与旧的DOM树进行对比，然后找出需要更新的节点进行更新。这种策略在处理大量数据或复杂渲染时表现较好，但在数据变化较小的情况下可能会浪费不必要的计算资源。 3）组件化 模板编写。 ● Vue 写常规 HTML 模板。写起来很接近标准 HTML 元素，只是多了一些属性。 ● React 推荐JSX写。 具体：React 中 render 函数支持闭包，所以 import 的组件在 render 中可直接调用。但 Vue 模板中用的数据都必须挂在 this 上进行中转，所以 import 一个组件后，还要在 components 中再声明。 4）监听数据变化实现原理不同 ● Vue 通过 getter/setter 及函数劫持，精确知道数据变化，不需特别优化就能达到很好的性能 ● React 默认比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的 vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。 5）高阶组件 react 可以通过高阶组件（HOC）扩展，Vue 通过 mixins 扩展。 高阶组件就是高阶函数，React 组件本身就是函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不能采用 HOC 来实现。 6）构建工具 ● React ==&gt; Create React APP ● Vue ==&gt; vue-cli 7）跨平台 ● React ==&gt; React Native ● Vue ==&gt; Weex</p><h2 id="spa-单页面" tabindex="-1">SPA 单页面 <a class="header-anchor" href="#spa-单页面" aria-label="Permalink to &quot;SPA 单页面&quot;">​</a></h2><p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容变换，UI 与用户的交互，避免页面重新加载。</p><p>优点：</p><p>● 用户体验好、快，内容改变不需要重新加载整个页面，避免不必要的跳转和重复渲染；所以相对对服务器压力小；</p><p>● 前后端分离，前端交互逻辑，后端数据处理；</p><p>缺点：</p><p>● 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p><p>● 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p><p>● SEO 难度较大：由于所有的内容都在一个页面中动态替换显示</p><h2 id="ssr服务端渲染" tabindex="-1">SSR服务端渲染 <a class="header-anchor" href="#ssr服务端渲染" aria-label="Permalink to &quot;SSR服务端渲染&quot;">​</a></h2><p>将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后把 html 直接返给客户端</p><p>● 更好 SEO，首屏加载速度更快 缺点：</p><p>● 开发条件受限，服务器端渲染只支持 beforeCreate 和 created 两个钩子；</p><p>● 需要外部扩展库时要特殊处理，服务端渲染的框架也要处于 Node.js 的运行环境；</p><p>● 更多的服务端负载。</p>',49),d=[l];function s(n,c,m,u,h,v){return a(),t("div",null,d)}const w=e(p,[["render",s]]);export{M as __pageData,w as default};
