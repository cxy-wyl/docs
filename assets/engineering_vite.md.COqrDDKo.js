import{_ as e,o as t,c as a,a5 as i}from"./chunks/framework.DnJ-_PtE.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/vite.md","filePath":"engineering/vite.md","lastUpdated":1718107892000}'),o={name:"engineering/vite.md"},r=i('<p>webpack开发生产环境都会编译，其实开发环境没必要编译成es5，目前浏览器都能识别es6，vite只是把vue文件编译成render函数让浏览器加载识别，不会编译es6代码 基 于 浏 览 器 原 生 ES imports 的 开 发 服 务 器 。 利 用 浏 览 器 解 析 imports ， 服 务 器 端 按 需 编 译 返 回 ， 跳 过 打 包 概 念 ， 服 务 器 随 起 随 用 。 同 时 不 仅 有 vue 文 件 支 持 ， 还 搞 定 热 更 新 ， 而 且 热 更 新 的 速 度 不 会 随 着 模 块 增 多 而 变 慢 。 针 对 生 产 环 境 则 可 以 把 同 一 份 代 码 用 rollup 打 包 。</p><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>vite主要有两个功能， 一个是开发过程中通过connect搭建了开发服务器跑在3000端口，这个服务器基于ESM，代表大部分代码无需编译直接传给浏览器，HMR速度快 一个是一套构建指令，用rollup打开代码，而且是预配置的，不需要自己配置 vite2.0由原来的core转成connect</p><h2 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h2><p>浏览器已经支持ESM，vite对加载的文件先处理成ESM模块，</p><h2 id="为什么快" tabindex="-1">为什么快 <a class="header-anchor" href="#为什么快" aria-label="Permalink to &quot;为什么快&quot;">​</a></h2><p>对三方库有预打包放在nodemodules下面的.vite文件夹下 内置了热更新 vite配置很少，自动支持多种文件格式 借用了ESbuild构建工具，支持多种源代码，ESbuild是用go语言写的，可以直接转成机器代码，无需经过字节码，充分利用了CPU多内核</p>',7),n=[r];function s(c,d,l,_,p,h){return t(),a("div",null,n)}const v=e(o,[["render",s]]);export{m as __pageData,v as default};
